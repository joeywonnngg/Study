   
    begin {
        if ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # users we're going to be searching for
        $TargetUsers = @()
        
        # random object for delay
        $randNo = New-Object System.Random
        
        # get the current user
        $CurrentUser = Get-NetCurrentUser
        $CurrentUserBase = ([Environment]::UserName).toLower()
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        "[*] Running Invoke-UserHunter with delay of $Delay"
        if($targetDomain){
            "[*] Domain: $targetDomain"
        }
        
        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }

        # if we get a specific username, only use that
        if ($UserName){
            "`r`n[*] Using target user '$UserName'..."
            $TargetUsers += $UserName.ToLower()
        }
        # get the users from a particular OU if one is specified
        elseif($OU){
            $TargetUsers = Get-NetUser -OU $OU | ForEach-Object {$_.samaccountname}
        }
        # use a specific LDAP query string to query for users
        elseif($Filter){
            $TargetUsers = Get-NetUser -Filter $Filter | ForEach-Object {$_.samaccountname}
        }
        # read in a target user list if we have one
        elseif($UserList){
            $TargetUsers = @()
            # make sure the list exists
            if (Test-Path -Path $UserList){
                $TargetUsers = Get-Content -Path $UserList 
            }
            else {
                Write-Warning "`r`n[!] Input file '$UserList' doesn't exist!`r`n"
                "`r`n[!] Input file '$UserList' doesn't exist!`r`n"
                return
            }
        }
        else{
            # otherwise default to the group name to query for target users
            "`r`n[*] Querying domain group '$GroupName' for target users..."
            $temp = Get-NetGroup -GroupName $GroupName -Domain $targetDomain
            # lower case all of the found usernames
            $TargetUsers = $temp | ForEach-Object {$_.ToLower() }
        }

        if (($TargetUsers -eq $null) -or ($TargetUsers.Count -eq 0)){
            Write-Warning "`r`n[!] No users found to search for!"
            return
        }
    }
    
    process {
        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
        $HostCount = $Hosts.Count
         "[*] Total number of hosts: $HostCount`r`n"

        $counter = 0

        foreach ($server in $Hosts){

            $counter = $counter + 1

            # make sure we get a server name
            if ($server -ne ''){
                # sleep for our semi-randomized interval
                Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
                
                Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"
                
                # optionally check if the server is up first
                $up = $true
                if(-not $NoPing){
                    $up = Test-Server -Server $server
                }
                if ($up){
                    # get active sessions and see if there's a target user there
                    $sessions = Get-NetSessions -HostName $server
                    foreach ($session in $sessions) {
                        $username = $session.sesi10_username
                        $cname = $session.sesi10_cname
                        $activetime = $session.sesi10_time
                        $idletime = $session.sesi10_idle_time
                        
                        # make sure we have a result
                        if (($username -ne $null) -and ($username.trim() -ne '') -and ($username.trim().toLower() -ne $CurrentUserBase)){
                            # if the session user is in the target list, display some output
                            if ($TargetUsers -contains $username){
                                $ip = Get-HostIP -hostname $server
                                "[+] Target user '$username' has a session on $server ($ip) from $cname"
                                
                                # see if we're checking to see if we have local admin access on this machine
                                if ($CheckAccess){
                                    if (Invoke-CheckLocalAdminAccess -Hostname $cname){
                                        "[+] Current user '$CurrentUser' has local admin access on $cname !"
                                    }
                                }
                            }
                        }
                    }
                    
                    # get any logged on users and see if there's a target user there
                    $users = Get-NetLoggedon -HostName $server
                    foreach ($user in $users) {
                        $username = $user.wkui1_username
                        $domain = $user.wkui1_logon_domain
                        
                        if (($username -ne $null) -and ($username.trim() -ne '')){
                            # if the session user is in the target list, display some output
                            if ($TargetUsers -contains $username){
                                $ip = Get-HostIP -hostname $server
                                # see if we're checking to see if we have local admin access on this machine
                                "[+] Target user '$username' logged into $server ($ip)"
                                
                                # see if we're checking to see if we have local admin access on this machine
                                if ($CheckAccess){
                                    if (Invoke-CheckLocalAdminAccess -Hostname $ip){
                                        "[+] Current user '$CurrentUser' has local admin access on $ip !"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


function Invoke-UserHunterThreaded {
    <#
        .SYNOPSIS
        Finds which machines users of a specified group are logged into.
        Threaded version of Invoke-UserHunter.

        Author: @harmj0y
        License: BSD 3-Clause
        
        .DESCRIPTION
        This function finds the local domain name for a host using Get-NetDomain,
        queries the domain for users of a specified group (default "domain admins")
        with Get-NetGroup or reads in a target user list, queries the domain for all 
        active machines with Get-NetComputers or reads in a pre-populated host list,
        randomly shuffles the target list, then for each server it gets a list of 
        active users with Get-NetSessions/Get-NetLoggedon. The found user list is compared 
        against the target list, and a status message is displayed for any hits. 
        The flag -CheckAccess will check each positive host to see if the current 
        user has local admin access to the machine.
        Threaded version of Invoke-UserHunter.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER GroupName
        Group name to query for target users.

        .PARAMETER OU
        The OU to pull users from.

        .PARAMETER Filter
        The complete LDAP query string to use to query for users.

        .PARAMETER UserName
        Specific username to search for.

        .PARAMETER UserList
        List of usernames to search for.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER CheckAccess
        Check if the current user has local admin access to found machines.

        .PARAMETER Domain
        Domain for query for machines.

        .PARAMETER MaxThreads
        The maximum concurrent threads to execute.

        .EXAMPLE
        > Invoke-UserHunter
        Finds machines on the local domain where domain admins are logged into.

        .EXAMPLE
        > Invoke-UserHunter -Domain 'testing'
        Finds machines on the 'testing' domain where domain admins are logged into.

        .EXAMPLE
        > Invoke-UserHunter -CheckAccess
        Finds machines on the local domain where domain admins are logged into
        and checks if the current user has local administrator access.

        .EXAMPLE
        > Invoke-UserHunter -UserList users.txt -HostList hosts.txt
        Finds machines in hosts.txt where any members of users.txt are logged in
        or have sessions.

        .EXAMPLE
        > Invoke-UserHunter -UserName jsmith -CheckAccess
        Find machines on the domain where jsmith is logged into and checks if 
        the current user has local administrator access.

        .LINK
        http://blog.harmj0y.net
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $GroupName = 'Domain Admins',

        [string]
        $OU,

        [string]
        $Filter,

        [string]
        $UserName,

        [Switch]
        $CheckAccess,

        [Switch]
        $NoPing,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [string]
        $UserList,

        [string]
        $Domain,

        [int]
        $MaxThreads = 10
    )
    
    begin {
        if ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # users we're going to be searching for
        $TargetUsers = @()
        
        # get the current user
        $CurrentUser = Get-NetCurrentUser
        $CurrentUserBase = ([Environment]::UserName).toLower()
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        "[*] Running Invoke-UserHunterThreaded with delay of $Delay"
        if($targetDomain){
            "[*] Domain: $targetDomain"
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }
        
        # if we get a specific username, only use that
        if ($UserName){
            "`r`n[*] Using target user '$UserName'..."
            $TargetUsers += $UserName.ToLower()
        }
        # get the users from a particular OU if one is specified
        elseif($OU){
            $TargetUsers = Get-NetUser -OU $OU | ForEach-Object {$_.samaccountname}
        }
        # use a specific LDAP query string to query for users
        elseif($Filter){
            $TargetUsers = Get-NetUser -Filter $Filter | ForEach-Object {$_.samaccountname}
        }
        # read in a target user list if we have one
        elseif($UserList){
            $TargetUsers = @()
            # make sure the list exists
            if (Test-Path -Path $UserList){
                $TargetUsers = Get-Content -Path $UserList 
            }
            else {
                Write-Warning "`r`n[!] Input file '$UserList' doesn't exist!`r`n"
                return
            }
        }
        else{
            # otherwise default to the group name to query for target users
            "`r`n[*] Querying domain group '$GroupName' for target users..."
            $temp = Get-NetGroup -GroupName $GroupName -Domain $targetDomain
            # lower case all of the found usernames
            $TargetUsers = $temp | ForEach-Object {$_.ToLower() }
        }
        
        if (($TargetUsers -eq $null) -or ($TargetUsers.Count -eq 0)){
            Write-Warning "`r`n[!] No users found to search for!"
            return $Null
        }

        # script block that eunmerates a server
        # this is called by the multi-threading code later
        $EnumServerBlock = {
            param($Server, $Ping, $TargetUsers, $CurrentUser, $CurrentUserBase)

            # optionally check if the server is up first
            $up = $true
            if($Ping){
                $up = Test-Server -Server $Server
            }
            if($up){
                # get active sessions and see if there's a target user there
                $sessions = Get-NetSessions -HostName $Server

                foreach ($session in $sessions) {
                    $username = $session.sesi10_username
                    $cname = $session.sesi10_cname
                    $activetime = $session.sesi10_time
                    $idletime = $session.sesi10_idle_time
                    
                    # make sure we have a result
                    if (($username -ne $null) -and ($username.trim() -ne '') -and ($username.trim().toLower() -ne $CurrentUserBase)){
                        # if the session user is in the target list, display some output
                        if ($TargetUsers -contains $username){
                            $ip = Get-HostIP -hostname $Server
                            "[+] Target user '$username' has a session on $Server ($ip) from $cname"
                            
                            # see if we're checking to see if we have local admin access on this machine
                            if ($CheckAccess){
                                if (Invoke-CheckLocalAdminAccess -Hostname $cname){
                                    "[+] Current user '$CurrentUser' has local admin access on $cname !"
                                }
                            }
                        }
                    }
                }
                
                # get any logged on users and see if there's a target user there
                $users = Get-NetLoggedon -HostName $Server
                foreach ($user in $users) {
                    $username = $user.wkui1_username
                    $domain = $user.wkui1_logon_domain
                    
                    if (($username -ne $null) -and ($username.trim() -ne '')){
                        # if the session user is in the target list, display some output
                        if ($TargetUsers -contains $username){
                            $ip = Get-HostIP -hostname $server
                            # see if we're checking to see if we have local admin access on this machine
                            "[+] Target user '$username' logged into $Server ($ip)"
                            
                            # see if we're checking to see if we have local admin access on this machine
                            if ($CheckAccess){
                                if (Invoke-CheckLocalAdminAccess -Hostname $ip){
                                    "[+] Current user '$CurrentUser' has local admin access on $ip !"
                                }
                            }
                        }
                    }
                }
            }
        }

        # Adapted from:
        #   http://powershell.org/wp/forums/topic/invpke-parallel-need-help-to-clone-the-current-runspace/
        $sessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
        $sessionState.ApartmentState = [System.Threading.Thread]::CurrentThread.GetApartmentState()
     
        # grab all the current variables for this runspace
        $MyVars = Get-Variable -Scope 1
     
        # these Variables are added by Runspace.Open() Method and produce Stop errors if you add them twice
        $VorbiddenVars = @("?","args","ConsoleFileName","Error","ExecutionContext","false","HOME","Host","input","InputObject","MaximumAliasCount","MaximumDriveCount","MaximumErrorCount","MaximumFunctionCount","MaximumHistoryCount","MaximumVariableCount","MyInvocation","null","PID","PSBoundParameters","PSCommandPath","PSCulture","PSDefaultParameterValues","PSHOME","PSScriptRoot","PSUICulture","PSVersionTable","PWD","ShellId","SynchronizedHash","true")
     
        # Add Variables from Parent Scope (current runspace) into the InitialSessionState 
        ForEach($Var in $MyVars) {
            If($VorbiddenVars -notcontains $Var.Name) {
            $sessionstate.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList $Var.name,$Var.Value,$Var.description,$Var.options,$Var.attributes))
            }
        }

        # Add Functions from current runspace to the InitialSessionState
        ForEach($Function in (Get-ChildItem Function:)) {
            $sessionState.Commands.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList $Function.Name, $Function.Definition))
        }
     
        # threading adapted from
        # https://github.com/darkoperator/Posh-SecMod/blob/master/Discovery/Discovery.psm1#L407
        # Thanks Carlos!   

        # create a pool of maxThread runspaces   
        $pool = [runspacefactory]::CreateRunspacePool(1, $MaxThreads, $sessionState, $host)
        $pool.Open()

        $jobs = @()   
        $ps = @()   
        $wait = @()

        $counter = 0
    }

    process {

        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
        $HostCount = $Hosts.Count
        "[*] Total number of hosts: $HostCount`r`n"

        foreach ($server in $Hosts){
            
            $counter = $counter + 1

            # make sure we get a server name
            if ($server -ne ''){
                Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"

                While ($($pool.GetAvailableRunspaces()) -le 0) {
                    Start-Sleep -milliseconds 500
                }
        
                # create a "powershell pipeline runner"   
                $ps += [powershell]::create()
       
                $ps[$counter].runspacepool = $pool

                # add the script block + arguments
                [void]$ps[$counter].AddScript($EnumServerBlock).AddParameter('Server', $server).AddParameter('Ping', -not $NoPing).AddParameter('TargetUsers', $TargetUsers).AddParameter('CurrentUser', $CurrentUser).AddParameter('CurrentUserBase', $CurrentUserBase)
        
                # start job
                $jobs += $ps[$counter].BeginInvoke();
         
                # store wait handles for WaitForAll call   
                $wait += $jobs[$counter].AsyncWaitHandle

            }
        }
    }

    end {

        Write-Verbose "Waiting for scanning threads to finish..."

        $waitTimeout = Get-Date

        while ($($jobs | ? {$_.IsCompleted -eq $false}).count -gt 0 -or $($($(Get-Date) - $waitTimeout).totalSeconds) -gt 60) {
                Start-Sleep -milliseconds 500
            } 

        # end async call   
        for ($y = 0; $y -lt $counter; $y++) {     

            try {   
                # complete async job   
                $ps[$y].EndInvoke($jobs[$y])   

            } catch {
                Write-Warning "error: $_"  
            }
            finally {
                $ps[$y].Dispose()
            }    
        }

        $pool.Dispose()
    }
}


function Invoke-StealthUserHunter {
    <#
        .SYNOPSIS
        Finds where users are logged into by checking the net sessions
        on common file servers (default) or through SPN records (-SPN).

        Author: @harmj0y
        License: BSD 3-Clause
        
        .DESCRIPTION
        This function issues one query on the domain to get users of a target group,
        issues one query on the domain to get all user information, extracts the 
        homeDirectory for each user, creates a unique list of servers used for 
        homeDirectories (i.e. file servers), and runs Get-NetSessions against the target 
        servers. Found users are compared against the users queried from the domain group,
        or pulled from a pre-populated user list. Significantly less traffic is generated 
        on average compared to Invoke-UserHunter, but not as many hosts are covered.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of servers to enumerate.

        .PARAMETER GroupName
        Group name to query for target users.

        .PARAMETER OU
        OU to query for target users.

        .PARAMETER Filter
        The complete LDAP query string to use to query for users.

        .PARAMETER UserName
        Specific username to search for.

        .PARAMETER SPN
        Use SPN records to get your target sets.

        .PARAMETER UserList
        List of usernames to search for.

        .PARAMETER CheckAccess
        Check if the current user has local admin access to found machines.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER Delay
        Delay between enumerating fileservers, defaults to 0

        .PARAMETER Jitter
        Jitter for the fileserver delay, defaults to +/- 0.3

        .PARAMETER Domain
        Domain to query for users file server locations.

        .EXAMPLE
        > Invoke-StealthUserHunter
        Finds machines on the local domain where domain admins have sessions from.

        .EXAMPLE
        > Invoke-StealthUserHunter -Domain testing
        Finds machines on the 'testing' domain where domain admins have sessions from.

        .EXAMPLE
        > Invoke-StealthUserHunter -UserList users.txt
        Finds machines on the local domain where users from a specified list have
        sessions from.

        .EXAMPLE
        > Invoke-StealthUserHunter -CheckAccess
        Finds machines on the local domain where domain admins have sessions from
        and checks if the current user has local administrator access to those 
        found machines.

        .EXAMPLE
        > Invoke-StealthUserHunter -GroupName "Power Users" -Delay 60
        Find machines on the domain where members of the "Power Users" groups  
        have sessions with a 60 second (+/- *.3) randomized delay between 
        touching each file server.

        .LINK
        http://blog.harmj0y.net
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $GroupName = 'Domain Admins',

        [string]
        $OU,

        [string]
        $Filter,

        [string]
        $UserName,

        [Switch]
        $SPN,

        [Switch]
        $CheckAccess,

        [Switch]
        $NoPing,

        [UInt32]
        $Delay = 0,

        [double]
        $Jitter = .3,

        [string]
        $UserList,

        [string]
        $Domain
    )
    
    begin {
        if ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # users we're going to be searching for
        $TargetUsers = @()
        
        # resulting servers to query
        $Servers = @()
        
        # random object for delay
        $randNo = New-Object System.Random
        
        # get the current user
        $CurrentUser = Get-NetCurrentUser
        $CurrentUserBase = ([Environment]::UserName)
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        "[*] Running Invoke-StealthUserHunter with delay of $Delay"
        if($targetDomain){
            "[*] Domain: $targetDomain"
        }

        # if we get a specific username, only use that
        if ($UserName){
            "`r`n[*] Using target user '$UserName'..."
            $TargetUsers += $UserName.ToLower()
        }
        # get the users from a particular OU if one is specified
        elseif($OU){
            $TargetUsers = Get-NetUser -OU $OU | ForEach-Object {$_.samaccountname}
        }
        # use a specific LDAP query string to query for users
        elseif($Filter){
            $TargetUsers = Get-NetUser -Filter $Filter | ForEach-Object {$_.samaccountname}
        }
        # read in a target user list if we have one
        elseif($UserList){
            $TargetUsers = @()
            # make sure the list exists
            if (Test-Path -Path $UserList){
                $TargetUsers = Get-Content -Path $UserList 
            }
            else {
                Write-Warning "`r`n[!] Input file '$UserList' doesn't exist!`r`n"
                "`r`n[!] Input file '$UserList' doesn't exist!`r`n"
                return
            }
        }
        else{
            # otherwise default to the group name to query for target users
            "`r`n[*] Querying domain group '$GroupName' for target users..."
            $temp = Get-NetGroup -GroupName $GroupName -Domain $targetDomain
            # lower case all of the found usernames
            $TargetUsers = $temp | ForEach-Object {$_.ToLower() }
        }
        
        if (($TargetUsers -eq $null) -or ($TargetUsers.Count -eq 0)){
            Write-Warning "`r`n[!] No users found to search for!"
            "`r`n[!] No users found to search for!"
            return
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }
        elseif($SPN){
            # set the unique set of SPNs from user objects
            $Hosts = Get-NetUserSPNs | Foreach-Object {
                $_.ServicePrincipalName | Foreach-Object {
                    ($_.split("/")[1]).split(":")[0]
                }
            } | Sort-Object | Get-Unique 
        }
    }

    process {

        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            [Array]$Hosts  = Get-NetFileServers -Domain $targetDomain
        }
        
        # randomize the host list if specified
        $Hosts = Get-ShuffledArray $Hosts
        $HostCount = $Hosts.Count
        "[*] Total number of hosts: $HostCount`r`n"

        $counter = 0
        
        # iterate through each target file server
        foreach ($server in $Hosts){
            
            $counter = $counter + 1
            
            Write-Verbose "[*] Enumerating host $server ($counter of $($Hosts.count))"

            # sleep for our semi-randomized interval
            Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
            
            # optionally check if the server is up first
            $up = $true
            if(-not $NoPing){
                $up = Test-Server -Server $server
            }
            if ($up){
                # grab all the sessions for this fileserver
                $sessions = Get-NetSessions $server
                
                # search through all the sessions for a target user
                foreach ($session in $sessions) {
                    Write-Debug "[*] Session: $session"
                    # extract fields we care about
                    $username = $session.sesi10_username
                    $cname = $session.sesi10_cname
                    $activetime = $session.sesi10_time
                    $idletime = $session.sesi10_idle_time
                    
                    # make sure we have a result
                    if (($username -ne $null) -and ($username.trim() -ne '') -and ($username.trim().toLower() -ne $CurrentUserBase)){
                        # if the session user is in the target list, display some output
                        if ($TargetUsers -contains $username){
                            $ip = Get-HostIP -hostname $server
                            "[+] Target user '$username' has a session on $server ($ip) from $cname"
                            
                            # see if we're checking to see if we have local admin access on this machine
                            if ($CheckAccess){
                                Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
                                if (Invoke-CheckLocalAdminAccess -Hostname $server){
                                    "[+] Current user '$CurrentUser' has local admin access on $server !"
                                }
                                if (Invoke-CheckLocalAdminAccess -Hostname $cname){
                                    "[+] Current user '$CurrentUser' has local admin access on $cname !"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}


function Invoke-UserProcessHunter {
    <#
        .SYNOPSIS
        Query the process lists of remote machines, searching for
        specific user processes.

        Author: @harmj0y
        License: BSD 3-Clause

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER GroupName
        Group name to query for target users.

        .PARAMETER OU
        The OU to pull users from.
        
        .PARAMETER Filter
        The complete LDAP filter string to use to query for users.

        .PARAMETER UserName
        Specific username to search for.

        .PARAMETER UserList
        List of usernames to search for.

        .PARAMETER RemoteUserName
        The "domain\username" to use for the WMI call on a remote system.
        If supplied, 'RemotePassword' must be supplied as well.

        .PARAMETER RemotePassword
        The password to use for the WMI call on a remote system.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER Delay
        Delay between enumerating hosts, defaults to 0

        .PARAMETER Jitter
        Jitter for the host delay, defaults to +/- 0.3

        .PARAMETER Domain
        Domain for query for machines.

        .EXAMPLE
        > Invoke-UserProcessHunter -Domain 'testing'
        Finds machines on the 'testing' domain where domain admins have a
        running process.

        .EXAMPLE
        > Invoke-UserProcessHunter -UserList users.txt -HostList hosts.txt
        Finds machines in hosts.txt where any members of users.txt have running
        processes.

        .EXAMPLE
        > Invoke-UserProcessHunter -GroupName "Power Users" -Delay 60
        Find machines on the domain where members of the "Power Users" groups have 
        running processes with a 60 second (+/- *.3) randomized delay between 
        touching each host.

        .LINK
        http://blog.harmj0y.net
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [string]
        $GroupName = 'Domain Admins',

        [string]
        $OU,

        [string]
        $Filter,

        [string]
        $UserName,

        [string]
        $RemoteUserName,

        [string]
        $RemotePassword,

        [Switch]
        $NoPing,

        [UInt32]
        $Delay = 0,

        [double]
        $Jitter = .3,

        [string]
        $UserList,

        [string]
        $Domain
    )
    
    begin {
        if ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # users we're going to be searching for
        $TargetUsers = @()
        
        # random object for delay
        $randNo = New-Object System.Random
        
        # get the current user
        $CurrentUser = Get-NetCurrentUser
        $CurrentUserBase = ([Environment]::UserName).toLower()
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        Write-Verbose "[*] Running Invoke-UserProcessHunter with a delay of $delay"
        if($targetDomain){
            Write-Verbose "[*] Domain: $targetDomain"
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }

        # if we get a specific username, only use that
        if ($UserName){
            $TargetUsers += $UserName.ToLower()
        }
        # get the users from a particular OU if one is specified
        elseif($OU){
            $TargetUsers = Get-NetUser -OU $OU | ForEach-Object {$_.samaccountname}
        }
        # use a specific LDAP query string to query for users
        elseif($Filter){
            $TargetUsers = Get-NetUser -Filter $Filter | ForEach-Object {$_.samaccountname}
        }
        # read in a target user list if we have one
        elseif($UserList){
            $TargetUsers = @()
            # make sure the list exists
            if (Test-Path -Path $UserList){
                $TargetUsers = Get-Content -Path $UserList 
            }
            else {
                Write-Warning "`r`n[!] Input file '$UserList' doesn't exist!`r`n"
                return
            }
        }
        else{
            # otherwise default to the group name to query for target users
            $temp = Get-NetGroup -GroupName $GroupName -Domain $targetDomain
            # lower case all of the found usernames
            $TargetUsers = $temp | ForEach-Object {$_.ToLower() }
        }

        $TargetUsers = $TargetUsers | ForEach-Object {$_.ToLower()}

        if (($TargetUsers -eq $null) -or ($TargetUsers.Count -eq 0)){
            Write-Warning "`r`n[!] No users found to search for!"
            return
        }
    }
    
    process {
        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
        $HostCount = $Hosts.Count

        $counter = 0

        foreach ($server in $Hosts){

            $counter = $counter + 1

            # make sure we get a server name
            if ($server -ne ''){
                # sleep for our semi-randomized interval
                Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
                
                Write-Verbose "[*] Enumerating target $server ($counter of $($Hosts.count))"
                
                # optionally check if the server is up first
                $up = $true
                if(-not $NoPing){
                    $up = Test-Server -Server $server
                }
                if ($up){
                    # try to enumerate all active processes on the remote host
                    # and see if any target users have a running process
                    $processes = Get-NetProcesses -RemoteUserName $RemoteUserName -RemotePassword $RemotePassword -HostName $server -ErrorAction SilentlyContinue

                    foreach ($process in $processes) {
                        # if the session user is in the target list, display some output
                        if ($TargetUsers -contains $process.User){
                            $process
                        }
                    }
                    # $targetProcesses | Format-Table -AutoSize
                }
            }
        }
    }
}


function Invoke-ProcessHunter {
    <#
        .SYNOPSIS
        Query the process lists of remote machines and searches
        the process list for a target process name.

        Author: @harmj0y
        License: BSD 3-Clause

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER ProcessName
        The name of the process to hunt. Defaults to putty.exe

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER RemoteUserName
        The "domain\username" to use for the WMI call on a remote system.
        If supplied, 'RemotePassword' must be supplied as well.

        .PARAMETER RemotePassword
        The password to use for the WMI call on a remote system.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER Delay
        Delay between enumerating hosts, defaults to 0

        .PARAMETER Jitter
        Jitter for the host delay, defaults to +/- 0.3

        .PARAMETER Domain
        Domain for query for machines.

        .EXAMPLE
        > Invoke-ProcessHunter -ProcessName customlogin.exe

        .LINK
        http://blog.harmj0y.net
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $ProcessName = "putty",

        [string]
        $HostList,

        [string]
        $HostFilter,

        [string]
        $RemoteUserName,

        [string]
        $RemotePassword,

        [Switch]
        $NoPing,

        [UInt32]
        $Delay = 0,

        [double]
        $Jitter = .3,

        [string]
        $Domain
    )
    
    begin {
        if ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # random object for delay
        $randNo = New-Object System.Random
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        Write-Verbose "[*] Running Invoke-ProcessHunter with a delay of $delay"
        if($targetDomain){
            Write-Verbose "[*] Domain: $targetDomain"
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }
    }
    
    process {
        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
        $HostCount = $Hosts.Count

        $counter = 0

        foreach ($server in $Hosts){

            $counter = $counter + 1

            # make sure we get a server name
            if ($server -ne ''){
                # sleep for our semi-randomized interval
                Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
                
                Write-Verbose "[*] Enumerating target $server ($counter of $($Hosts.count))"
                
                # optionally check if the server is up first
                $up = $true
                if(-not $NoPing){
                    $up = Test-Server -Server $server
                }
                if ($up){
                    # try to enumerate all active processes on the remote host
                    # and search for a specific process name
                    $processes = Get-NetProcesses -RemoteUserName $RemoteUserName -RemotePassword $RemotePassword -HostName $server -ErrorAction SilentlyContinue

                    foreach ($process in $processes) {
                        # if the session user is in the target list, display some output
                        if ($process.Process -match $ProcessName){
                            $process
                        }
                    }
                    # $targetProcesses | Format-Table -AutoSize
                }
            }
        }
    }
}


function Invoke-UserEventHunter {
    <#
        .SYNOPSIS
        Queries all domain controllers on the network for account
        logon events (ID 4624) and TGT request events (ID 4768), 
        searching for target users.

        Note: Domain Admin (or equiv) rights are needed to query
        this information from the DCs.

        Author: @sixdub, @harmj0y
        License: BSD 3-Clause

        .PARAMETER GroupName
        Group name to query for target users.

        .PARAMETER OU
        The OU to pull users from.
        
        .PARAMETER Filter
        The complete LDAP filter string to use to query for users.

        .PARAMETER UserName
        Specific username to search for.

        .PARAMETER UserList
        List of usernames to search for.

        .PARAMETER Domain
        Domain to query for DCs and users.

        .PARAMETER SearchDays
        Number of days back to search logs for. Default 3.
    #>
    
    [CmdletBinding()]
    param(
        [string]
        $GroupName = 'Domain Admins',

        [string]
        $OU,

        [string]
        $Filter,

        [string]
        $UserName,

        [string]
        $UserList,

        [string]
        $Domain,

        [int32]
        $SearchDays = 3
    )
    
    if ($PSBoundParameters['Debug']) {
        $DebugPreference = 'Continue'
    }
    
    # users we're going to be searching for
    $TargetUsers = @()
    
    # if we get a specific username, only use that
    if ($UserName){
        $TargetUsers += $UserName.ToLower()
    }
    # get the users from a particular OU/filter string if one is specified
    elseif($OU -or $Filter){
        $TargetUsers = Get-NetUser -Filter $Filter -OU $OU -Domain $Domain | ForEach-Object {$_.samaccountname}
    }
    # read in a target user list if we have one
    elseif($UserList){
        $TargetUsers = @()
        # make sure the list exists
        if (Test-Path -Path $UserList){
            $TargetUsers = Get-Content -Path $UserList 
        }
        else {
            Write-Warning "[!] Input file '$UserList' doesn't exist!`r`n"
            return
        }
    }
    else{
        # otherwise default to the group name to query for target users
        $temp = Get-NetGroup -GroupName $GroupName -Domain $Domain
        # lower case all of the found usernames
        $TargetUsers = $temp | ForEach-Object {$_.ToLower() }
    }

    $TargetUsers = $TargetUsers | ForEach-Object {$_.ToLower()}

    if (($TargetUsers -eq $null) -or ($TargetUsers.Count -eq 0)){
        Write-Warning "[!] No users found to search for!"
        return
    }

    $DomainControllers = Get-NetDomainControllers -Domain $Domain | % {$_.Name}

    foreach ($DC in $DomainControllers){
        Write-Verbose "[*] Querying domain controller $DC for event logs"

        Get-UserTGTEvents -HostName $DC -DateStart ([DateTime]::Today.AddDays(-$SearchDays)) | Where-Object {
            # filter for the target user set
            $TargetUsers -contains $_.UserName
        }
                
        Get-UserLogonEvents -HostName $DC -DateStart ([DateTime]::Today.AddDays(-$SearchDays)) | Where-Object {
            # filter for the target user set
            $TargetUsers -contains $_.UserName
        }
    }
}


function Invoke-ShareFinder {
    <#
        .SYNOPSIS
        Finds (non-standard) shares on machines in the domain.

        Author: @harmj0y
        License: BSD 3-Clause
        
        .DESCRIPTION
        This function finds the local domain name for a host using Get-NetDomain,
        queries the domain for all active machines with Get-NetComputers, then for 
        each server it lists of active shares with Get-NetShare. Non-standard shares 
        can be filtered out with -Exclude* flags.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER ExcludeStandard
        Exclude standard shares from display (C$, IPC$, print$ etc.)

        .PARAMETER ExcludePrint
        Exclude the print$ share

        .PARAMETER ExcludeIPC
        Exclude the IPC$ share

        .PARAMETER CheckShareAccess
        Only display found shares that the local user has access to.

        .PARAMETER CheckAdmin
        Only display ADMIN$ shares the local user has access to.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER Delay
        Delay between enumerating hosts, defaults to 0

        .PARAMETER Jitter
        Jitter for the host delay, defaults to +/- 0.3

        .PARAMETER Domain
        Domain to query for machines.

        .EXAMPLE
        > Invoke-ShareFinder
        Find shares on the domain.
        
        .EXAMPLE
        > Invoke-ShareFinder -ExcludeStandard
        Find non-standard shares on the domain.

        .EXAMPLE
        > Invoke-ShareFinder -Delay 60
        Find shares on the domain with a 60 second (+/- *.3) 
        randomized delay between touching each host.

        .EXAMPLE
        > Invoke-ShareFinder -HostList hosts.txt
        Find shares for machines in the specified hostlist.

        .LINK
        http://blog.harmj0y.net
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [Switch]
        $ExcludeStandard,

        [Switch]
        $ExcludePrint,

        [Switch]
        $ExcludeIPC,

        [Switch]
        $NoPing,

        [Switch]
        $CheckShareAccess,

        [Switch]
        $CheckAdmin,

        [UInt32]
        $Delay = 0,

        [double]
        $Jitter = .3,

        [String]
        $Domain
    )
    
    begin {
        If ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # figure out the shares we want to ignore
        [String[]] $excludedShares = @('')
        
        if ($ExcludePrint){
            $excludedShares = $excludedShares + "PRINT$"
        }
        if ($ExcludeIPC){
            $excludedShares = $excludedShares + "IPC$"
        }
        if ($ExcludeStandard){
            $excludedShares = @('', "ADMIN$", "IPC$", "C$", "PRINT$")
        }
        
        # random object for delay
        $randNo = New-Object System.Random
        
        # get the current user
        $CurrentUser = Get-NetCurrentUser
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        Write-Verbose "[*] Running Invoke-ShareFinder with delay of $Delay"
        if($targetDomain){
            Write-Version "[*] Domain: $targetDomain"
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else {
                Write-Warning "`r`n[!] Input file '$HostList' doesn't exist!`r`n"
                return $null
            }
        }
        else{
            # otherwise, query the domain for target hosts
            if($HostFilter){
                Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
                $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
            }
            else {
                Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
                $Hosts = Get-NetComputers -Domain $targetDomain
            }
        }
    }

    process{
        
        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts

        $counter = 0
        
        foreach ($server in $Hosts){
            
            $counter = $counter + 1
            
            Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"
            
            if ($server -ne ''){
                # sleep for our semi-randomized interval
                Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
                
                # optionally check if the server is up first
                $up = $true
                if(-not $NoPing){
                    $up = Test-Server -Server $server
                }
                if($up){
                    # get the shares for this host and display what we find
                    $shares = Get-NetShare -HostName $server
                    foreach ($share in $shares) {
                        Write-Debug "[*] Server share: $share"
                        $netname = $share.shi1_netname
                        $remark = $share.shi1_remark
                        $path = '\\'+$server+'\'+$netname

                        # make sure we get a real share name back
                        if (($netname) -and ($netname.trim() -ne '')){
                            
                            # if we're just checking for access to ADMIN$
                            if($CheckAdmin){
                                if($netname.ToUpper() -eq "ADMIN$"){
                                    try{
                                        $f=[IO.Directory]::GetFiles($path)
                                        "\\$server\$netname `t- $remark"
                                    }
                                    catch {}
                                }
                            }
                            
                            # skip this share if it's in the exclude list
                            elseif ($excludedShares -notcontains $netname.ToUpper()){
                                # see if we want to check access to this share
                                if($CheckShareAccess){
                                    # check if the user has access to this path
                                    try{
                                        $f=[IO.Directory]::GetFiles($path)
                                        "\\$server\$netname `t- $remark"
                                    }
                                    catch {}
                                }
                                else{
                                    "\\$server\$netname `t- $remark"
                                }
                            } 
                        }           
                    }
                }
            }
        }
    }
}


function Invoke-ShareFinderThreaded {
    <#
        .SYNOPSIS
        Finds (non-standard) shares on machines in the domain.
        Threaded version of Invoke-ShareFinder.

        Author: @harmj0y
        License: BSD 3-Clause
        
        .DESCRIPTION
        This function finds the local domain name for a host using Get-NetDomain,
        queries the domain for all active machines with Get-NetComputers, then for 
        each server it lists of active shares with Get-NetShare. Non-standard shares 
        can be filtered out with -Exclude* flags.
        Threaded version of Invoke-ShareFinder.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER ExcludedShares
        Shares to exclude from output, wildcards accepted (i.e. IPC*)

        .PARAMETER CheckShareAccess
        Only display found shares that the local user has access to.

        .PARAMETER CheckAdmin
        Only display ADMIN$ shares the local user has access to.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER Domain
        Domain to query for machines.

        .PARAMETER MaxThreads
        The maximum concurrent threads to execute.

        .EXAMPLE
        > Invoke-ShareFinder
        Find shares on the domain.
        
        .EXAMPLE
        > Invoke-ShareFinder -ExcludedShares IPC$,PRINT$
        Find shares on the domain excluding IPC$ and PRINT$

        .EXAMPLE
        > Invoke-ShareFinder -HostList hosts.txt
        Find shares for machines in the specified hostlist.

        .LINK
        http://blog.harmj0y.net
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [string[]]
        $ExcludedShares,

        [Switch] 
        $CheckShareAccess,

        [Switch] 
        $NoPing,

        [string]
        $Domain,

        [Int]
        $MaxThreads = 10
    )
    
    begin {
        If ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        $currentUser = ([Environment]::UserName).toLower()
        
        Write-Verbose "[*] Running Invoke-ShareFinderThreaded with delay of $Delay"
        if($targetDomain){
            Write-Verbose "[*] Domain: $targetDomain"
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }
        
        # script block that eunmerates a server
        # this is called by the multi-threading code later
        $EnumServerBlock = {
            param($Server, $Ping, $CheckShareAccess, $ExcludedShares, $CheckAdmin)

            # optionally check if the server is up first
            $up = $true
            if($Ping){
                $up = Test-Server -Server $Server
            }
            if($up){
                # get the shares for this host and check what we find
                $shares = Get-NetShare -HostName $Server
                foreach ($share in $shares) {
                    Write-Debug "[*] Server share: $share"
                    $netname = $share.shi1_netname
                    $remark = $share.shi1_remark
                    $path = '\\'+$server+'\'+$netname

                    # make sure we get a real share name back
                    if (($netname) -and ($netname.trim() -ne '')){
                        # if we're just checking for access to ADMIN$
                        if($CheckAdmin){
                            if($netname.ToUpper() -eq "ADMIN$"){
                                try{
                                    $f=[IO.Directory]::GetFiles($path)
                                    "\\$server\$netname `t- $remark"
                                }
                                catch {}
                            }
                        }
                        # skip this share if it's in the exclude list
                        elseif ($excludedShares -notcontains $netname.ToUpper()){
                            # see if we want to check access to this share
                            if($CheckShareAccess){
                                # check if the user has access to this path
                                try{
                                    $f=[IO.Directory]::GetFiles($path)
                                    "\\$server\$netname `t- $remark"
                                }
                                catch {}
                            }
                            else{
                                "\\$server\$netname `t- $remark"
                            }
                        } 
                    }
                }
            }
        }

        # Adapted from:
        #   http://powershell.org/wp/forums/topic/invpke-parallel-need-help-to-clone-the-current-runspace/
        $sessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
        $sessionState.ApartmentState = [System.Threading.Thread]::CurrentThread.GetApartmentState()
     
        # grab all the current variables for this runspace
        $MyVars = Get-Variable -Scope 1
     
        # these Variables are added by Runspace.Open() Method and produce Stop errors if you add them twice
        $VorbiddenVars = @("?","args","ConsoleFileName","Error","ExecutionContext","false","HOME","Host","input","InputObject","MaximumAliasCount","MaximumDriveCount","MaximumErrorCount","MaximumFunctionCount","MaximumHistoryCount","MaximumVariableCount","MyInvocation","null","PID","PSBoundParameters","PSCommandPath","PSCulture","PSDefaultParameterValues","PSHOME","PSScriptRoot","PSUICulture","PSVersionTable","PWD","ShellId","SynchronizedHash","true")
     
        # Add Variables from Parent Scope (current runspace) into the InitialSessionState 
        ForEach($Var in $MyVars) {
            If($VorbiddenVars -notcontains $Var.Name) {
            $sessionstate.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList $Var.name,$Var.Value,$Var.description,$Var.options,$Var.attributes))
            }
        }

        # Add Functions from current runspace to the InitialSessionState
        ForEach($Function in (Get-ChildItem Function:)) {
            $sessionState.Commands.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList $Function.Name, $Function.Definition))
        }
     
        # threading adapted from
        # https://github.com/darkoperator/Posh-SecMod/blob/master/Discovery/Discovery.psm1#L407
        # Thanks Carlos!   
        $counter = 0

        # create a pool of maxThread runspaces   
        $pool = [runspacefactory]::CreateRunspacePool(1, $MaxThreads, $sessionState, $host)
        $pool.Open()

        $jobs = @()   
        $ps = @()   
        $wait = @()

        $counter = 0
    }

    process {

        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
        $HostCount = $Hosts.Count
        Write-Verbose "[*] Total number of hosts: $HostCount"

        foreach ($server in $Hosts){
            
            $counter = $counter + 1

            # make sure we get a server name
            if ($server -ne ''){
                Write-Verbose "[*] Enumerating server $server $($counter) of $($Hosts.count))"

                While ($($pool.GetAvailableRunspaces()) -le 0) {
                    Start-Sleep -milliseconds 500
                }
        
                # create a "powershell pipeline runner"   
                $ps += [powershell]::create()
       
                $ps[$counter].runspacepool = $pool

                # add the script block + arguments
                [void]$ps[$counter].AddScript($EnumServerBlock).AddParameter('Server', $server).AddParameter('Ping', -not $NoPing).AddParameter('CheckShareAccess', $CheckShareAccess).AddParameter('ExcludedShares', $ExcludedShares)
        
                # start job
                $jobs += $ps[$counter].BeginInvoke();
         
                # store wait handles for WaitForAll call   
                $wait += $jobs[$counter].AsyncWaitHandle
            }
        }
    }

    end {
        Write-Verbose "Waiting for scanning threads to finish..."

        $waitTimeout = Get-Date

        while ($($jobs | ? {$_.IsCompleted -eq $false}).count -gt 0 -or $($($(Get-Date) - $waitTimeout).totalSeconds) -gt 60) {
                Start-Sleep -milliseconds 500
            } 

        # end async call   
        for ($y = 0; $y -lt $counter; $y++) {     

            try {   
                # complete async job   
                $ps[$y].EndInvoke($jobs[$y])   

            } catch {
                Write-Warning "error: $_"  
            }
            finally {
                $ps[$y].Dispose()
            }    
        }
        $pool.Dispose()
    }
}


function Invoke-FileFinder {
    <#
        .SYNOPSIS
        Finds sensitive files on the domain.

        Author: @harmj0y
        License: BSD 3-Clause

        .DESCRIPTION
        This function finds the local domain name for a host using Get-NetDomain,
        queries the domain for all active machines with Get-NetComputers, grabs
        the readable shares for each server, and recursively searches every
        share for files with specific keywords in the name.
        If a share list is passed, EVERY share is enumerated regardless of
        other options.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER ShareList
        List if \\HOST\shares to search through.

        .PARAMETER Terms
        Terms to search for.

        .PARAMETER OfficeDocs
        Search for office documents (*.doc*, *.xls*, *.ppt*)

        .PARAMETER FreshEXES
        Find .EXEs accessed within the last week.

        .PARAMETER AccessDateLimit
        Only return files with a LastAccessTime greater than this date value.

        .PARAMETER WriteDateLimit
        Only return files with a LastWriteTime greater than this date value.

        .PARAMETER CreateDateLimit
        Only return files with a CreationDate greater than this date value.

        .PARAMETER IncludeC
        Include any C$ shares in recursive searching (default ignore).

        .PARAMETER IncludeAdmin
        Include any ADMIN$ shares in recursive searching (default ignore).

        .PARAMETER ExcludeFolders
        Exclude folders from the search results.

        .PARAMETER ExcludeHidden
        Exclude hidden files and folders from the search results.

        .PARAMETER CheckWriteAccess
        Only returns files the current user has write access to.

        .PARAMETER OutFile
        Output results to a specified csv output file.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER Delay
        Delay between enumerating hosts, defaults to 0

        .PARAMETER Jitter
        Jitter for the host delay, defaults to +/- 0.3

        .PARAMETER Domain
        Domain to query for machines

        .EXAMPLE
        > Invoke-FileFinder
        Find readable files on the domain with 'pass', 'sensitive', 
        'secret', 'admin', 'login', or 'unattend*.xml' in the name,
        
        .EXAMPLE
        > Invoke-FileFinder -Domain testing
        Find readable files on the 'testing' domain with 'pass', 'sensitive', 
        'secret', 'admin', 'login', or 'unattend*.xml' in the name,
        
        .EXAMPLE
        > Invoke-FileFinder -IncludeC 
        Find readable files on the domain with 'pass', 'sensitive', 
        'secret', 'admin', 'login' or 'unattend*.xml' in the name, 
        including C$ shares.

        .EXAMPLE
        > Invoke-FileFinder -ShareList shares.txt -Terms accounts,ssn -OutFile out.csv
        Enumerate a specified share list for files with 'accounts' or
        'ssn' in the name, and write everything to "out.csv"

        .LINK
        http://www.harmj0y.net/blog/redteaming/file-server-triage-on-red-team-engagements/
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [string]
        $ShareList,
        
        [Switch]
        $OfficeDocs,

        [Switch]
        $FreshEXES,
        
        [string[]]
        $Terms,
        
        [string]
        $AccessDateLimit = '1/1/1970',
        
        [string]
        $WriteDateLimit = '1/1/1970',
        
        [string]
        $CreateDateLimit = '1/1/1970',
        
        [Switch] 
        $IncludeC,
        
        [Switch] 
        $IncludeAdmin,
        
        [Switch] 
        $ExcludeFolders,
        
        [Switch] 
        $ExcludeHidden,
        
        [Switch] 
        $CheckWriteAccess,
        
        [string] 
        $OutFile,
        
        [Switch]
        $NoPing,
        
        [UInt32]
        $Delay = 0,

        [double]
        $Jitter = .3,

        [string]
        $Domain
    )

    begin {
    
        If ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # figure out the shares we want to ignore
        [String[]] $excludedShares = @("C$", "ADMIN$")
       
        # random object for delay
        $randNo = New-Object System.Random

        # see if we're specifically including any of the normally excluded sets
        if ($IncludeC){
            if ($IncludeAdmin){
                $excludedShares = @()
            }
            else{
                $excludedShares = @("ADMIN$")
            }
        }

        if ($IncludeAdmin){
            if ($IncludeC){
                $excludedShares = @()
            }
            else{
                $excludedShares = @("C$")
            }
        }
        
        # delete any existing output file if it already exists
        If ($OutFile -and (Test-Path -Path $OutFile)){ Remove-Item -Path $OutFile }
        
        # if we are passed a share list, enumerate each with appropriate options, then return
        if($ShareList){
            if (Test-Path -Path $ShareList){
                foreach ($Item in Get-Content -Path $ShareList) {
                    if (($Item -ne $null) -and ($Item.trim() -ne '')){
                        
                        # exclude any "[tab]- commants", i.e. the output from Invoke-ShareFinder
                        $share = $Item.Split("`t")[0]
                        
                        # get just the share name from the full path
                        $shareName = $share.split('\')[3]
                        
                        $cmd = "Invoke-SearchFiles -Path $share $(if($Terms){`"-Terms $($Terms -join ',')`"}) $(if($ExcludeFolders){`"-ExcludeFolders`"}) $(if($ExcludeHidden){`"-ExcludeHidden`"}) $(if($FreshEXES){`"-FreshEXES`"}) $(if($OfficeDocs){`"-OfficeDocs`"}) $(if($CheckWriteAccess){`"-CheckWriteAccess`"}) $(if($OutFile){`"-OutFile $OutFile`"})"
                        
                        Write-Verbose "[*] Enumerating share $share"
                        Invoke-Expression $cmd    
                    }
                }
            }
            else {
                Write-Warning "`r`n[!] Input file '$ShareList' doesn't exist!`r`n"
                return $null
            }
            return
        }
        else{
            # if we aren't using a share list, first get the target domain
            if($Domain){
                $targetDomain = $Domain
            }
            else{
                # use the local domain
                $targetDomain = $null
            }
            
            Write-Verbose "[*] Running Invoke-FileFinder with delay of $Delay"
            if($targetDomain){
                Write-Verbose "[*] Domain: $targetDomain"
            }

            # if we're using a host list, read the targets in and add them to the target list
            if($HostList){
                if (Test-Path -Path $HostList){
                    $Hosts = Get-Content -Path $HostList
                }
                else{
                    Write-Warning "[!] Input file '$HostList' doesn't exist!"
                    "[!] Input file '$HostList' doesn't exist!"
                    return
                }
            }
            elseif($HostFilter){
                Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
                $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
            }
        }
    }

    process {
    
        if ( ((-not ($Hosts)) -or ($Hosts.length -eq 0)) -and (-not $ShareList) ) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }

        # randomize the server list
        $Hosts = Get-ShuffledArray $Hosts

        # return/output the current status lines
        $counter = 0
        
        foreach ($server in $Hosts){
            
            $counter = $counter + 1
            
            Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"
            
            if ($server -and ($server -ne '')){
                # sleep for our semi-randomized interval
                Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
                
                # optionally check if the server is up first
                $up = $true
                if(-not $NoPing){
                    $up = Test-Server -Server $server
                }
                if($up){
                    # get the shares for this host and display what we find
                    $shares = Get-NetShare -HostName $server
                    foreach ($share in $shares) {
                        Write-Debug "[*] Server share: $share"
                        $netname = $share.shi1_netname
                        $remark = $share.shi1_remark
                        $path = '\\'+$server+'\'+$netname
                        
                        # make sure we get a real share name back
                        if (($netname) -and ($netname.trim() -ne '')){
                            
                            # skip this share if it's in the exclude list
                            if ($excludedShares -notcontains $netname.ToUpper()){
                                
                                # check if the user has access to this path
                                try{
                                    $f=[IO.Directory]::GetFiles($path)
                                    
                                    $cmd = "Invoke-SearchFiles -Path $path $(if($Terms){`"-Terms $($Terms -join ',')`"}) $(if($ExcludeFolders){`"-ExcludeFolders`"}) $(if($OfficeDocs){`"-OfficeDocs`"}) $(if($ExcludeHidden){`"-ExcludeHidden`"}) $(if($FreshEXES){`"-FreshEXES`"}) $(if($CheckWriteAccess){`"-CheckWriteAccess`"}) $(if($OutFile){`"-OutFile $OutFile`"})"
                                    
                                    Write-Verbose "[*] Enumerating share $path"
                                    
                                    Invoke-Expression $cmd
                                }
                                catch {}
                                
                            } 
                            
                        }
                        
                    }
                }   
            }
        }
    }
}


function Invoke-FileFinderThreaded {
    <#
        .SYNOPSIS
        Finds sensitive files on the domain.

        Author: @harmj0y
        License: BSD 3-Clause

        .DESCRIPTION
        This function finds the local domain name for a host using Get-NetDomain,
        queries the domain for all active machines with Get-NetComputers, grabs
        the readable shares for each server, and recursively searches every
        share for files with specific keywords in the name.
        If a share list is passed, EVERY share is enumerated regardless of
        other options.
        Threaded version of Invoke-FileFinder

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER ShareList
        List if \\HOST\shares to search through.

        .PARAMETER Terms
        Terms to search for.

        .PARAMETER OfficeDocs
        Search for office documents (*.doc*, *.xls*, *.ppt*)

        .PARAMETER FreshEXES
        Find .EXEs accessed within the last week.

        .PARAMETER AccessDateLimit
        Only return files with a LastAccessTime greater than this date value.

        .PARAMETER WriteDateLimit
        Only return files with a LastWriteTime greater than this date value.

        .PARAMETER CreateDateLimit
        Only return files with a CreationDate greater than this date value.

        .PARAMETER IncludeC
        Include any C$ shares in recursive searching (default ignore).

        .PARAMETER IncludeAdmin
        Include any ADMIN$ shares in recursive searching (default ignore).

        .PARAMETER ExcludeFolders
        Exclude folders from the search results.

        .PARAMETER ExcludeHidden
        Exclude hidden files and folders from the search results.

        .PARAMETER CheckWriteAccess
        Only returns files the current user has write access to.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER Delay
        Delay between enumerating hosts, defaults to 0

        .PARAMETER Jitter
        Jitter for the host delay, defaults to +/- 0.3

        .PARAMETER Domain
        Domain to query for machines

        .EXAMPLE
        > Invoke-FileFinderThreaded
        Find readable files on the domain with 'pass', 'sensitive', 
        'secret', 'admin', 'login', or 'unattend*.xml' in the name,
        
        .EXAMPLE
        > Invoke-FileFinder -Domain testing
        Find readable files on the 'testing' domain with 'pass', 'sensitive', 
        'secret', 'admin', 'login', or 'unattend*.xml' in the name,

        .EXAMPLE
        > Invoke-FileFinderThreaded -ShareList shares.txt -Terms accounts,ssn
        Enumerate a specified share list for files with 'accounts' or
        'ssn' in the name

        .LINK
        http://www.harmj0y.net/blog/redteaming/file-server-triage-on-red-team-engagements/
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [string]
        $ShareList,
        
        [Switch]
        $OfficeDocs,

        [Switch]
        $FreshEXES,
        
        [string[]]
        $Terms,
        
        [string]
        $AccessDateLimit = '1/1/1970',
        
        [string]
        $WriteDateLimit = '1/1/1970',
        
        [string]
        $CreateDateLimit = '1/1/1970',
        
        [Switch] 
        $IncludeC,
        
        [Switch] 
        $IncludeAdmin,
        
        [Switch] 
        $ExcludeFolders,
        
        [Switch] 
        $ExcludeHidden,
        
        [Switch] 
        $CheckWriteAccess,
        
        [Switch]
        $NoPing,

        [string]
        $Domain,

        [Int]
        $MaxThreads = 10
    )
    
    begin {
        If ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # figure out the shares we want to ignore
        [String[]] $excludedShares = @("C$", "ADMIN$")
        
        # see if we're specifically including any of the normally excluded sets
        if ($IncludeC){
            if ($IncludeAdmin){
                $excludedShares = @()
            }
            else{
                $excludedShares = @("ADMIN$")
            }
        }
        if ($IncludeAdmin){
            if ($IncludeC){
                $excludedShares = @()
            }
            else{
                $excludedShares = @("C$")
            }
        }
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        Write-Verbose "[*] Running Invoke-FileFinderThreaded with delay of $Delay"
        if($targetDomain){
            Write-Verbose "[*] Domain: $targetDomain"
        }

        $shares = @()
        $servers = @()

        # if we're hard-passed a set of shares
        if($ShareList){
            if (Test-Path -Path $ShareList){
                foreach ($Item in Get-Content -Path $ShareList) {
                    if (($Item -ne $null) -and ($Item.trim() -ne '')){
                        # exclude any "[tab]- commants", i.e. the output from Invoke-ShareFinder
                        $share = $Item.Split("`t")[0]
                        $shares += $share
                    }
                }
            }
            else {
                Write-Warning "`r`n[!] Input file '$ShareList' doesn't exist!`r`n"
                return $null
            }
        }
        else{
            # otherwise if we're using a host list, read the targets in and add them to the target list
            if($HostList){
                if (Test-Path -Path $HostList){
                    $Hosts = Get-Content -Path $HostList
                }
                else{
                    Write-Warning "[!] Input file '$HostList' doesn't exist!"
                    "[!] Input file '$HostList' doesn't exist!"
                    return
                }
            }
            elseif($HostFilter){
                Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
                $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
            }
        }

        # script blocks that eunmerates share or a server
        # these are called by the multi-threading code later
        $EnumShareBlock = {
            param($Share, $Terms, $ExcludeFolders, $ExcludeHidden, $FreshEXES, $OfficeDocs, $CheckWriteAccess)
            
            $cmd = "Invoke-SearchFiles -Path $share $(if($Terms){`"-Terms $($Terms -join ',')`"}) $(if($ExcludeFolders){`"-ExcludeFolders`"}) $(if($ExcludeHidden){`"-ExcludeHidden`"}) $(if($FreshEXES){`"-FreshEXES`"}) $(if($OfficeDocs){`"-OfficeDocs`"}) $(if($CheckWriteAccess){`"-CheckWriteAccess`"})"

            Write-Verbose "[*] Enumerating share $share"
            Invoke-Expression $cmd    
        }
        $EnumServerBlock = {
            param($Server, $Ping, $excludedShares, $Terms, $ExcludeFolders, $OfficeDocs, $ExcludeHidden, $FreshEXES, $CheckWriteAccess)

            # optionally check if the server is up first
            $up = $true
            if($Ping){
                $up = Test-Server -Server $Server
            }
            if($up){

                # get the shares for this host and display what we find
                $shares = Get-NetShare -HostName $server
                foreach ($share in $shares) {

                    $netname = $share.shi1_netname
                    $remark = $share.shi1_remark
                    $path = '\\'+$server+'\'+$netname
                    
                    # make sure we get a real share name back
                    if (($netname) -and ($netname.trim() -ne '')){
                        
                        # skip this share if it's in the exclude list
                        if ($excludedShares -notcontains $netname.ToUpper()){
                            # check if the user has access to this path
                            try{
                                $f=[IO.Directory]::GetFiles($path)

                                $cmd = "Invoke-SearchFiles -Path $path $(if($Terms){`"-Terms $($Terms -join ',')`"}) $(if($ExcludeFolders){`"-ExcludeFolders`"}) $(if($OfficeDocs){`"-OfficeDocs`"}) $(if($ExcludeHidden){`"-ExcludeHidden`"}) $(if($FreshEXES){`"-FreshEXES`"}) $(if($CheckWriteAccess){`"-CheckWriteAccess`"})"
                                Invoke-Expression $cmd
                            }
                            catch {
                                Write-Debug "[!] No access to $path"
                            }
                        } 
                    }
                }
                
            }
        }

        # Adapted from:
        #   http://powershell.org/wp/forums/topic/invpke-parallel-need-help-to-clone-the-current-runspace/
        $sessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
        $sessionState.ApartmentState = [System.Threading.Thread]::CurrentThread.GetApartmentState()
     
        # grab all the current variables for this runspace
        $MyVars = Get-Variable -Scope 1
     
        # these Variables are added by Runspace.Open() Method and produce Stop errors if you add them twice
        $VorbiddenVars = @("?","args","ConsoleFileName","Error","ExecutionContext","false","HOME","Host","input","InputObject","MaximumAliasCount","MaximumDriveCount","MaximumErrorCount","MaximumFunctionCount","MaximumHistoryCount","MaximumVariableCount","MyInvocation","null","PID","PSBoundParameters","PSCommandPath","PSCulture","PSDefaultParameterValues","PSHOME","PSScriptRoot","PSUICulture","PSVersionTable","PWD","ShellId","SynchronizedHash","true")
     
        # Add Variables from Parent Scope (current runspace) into the InitialSessionState 
        ForEach($Var in $MyVars) {
            If($VorbiddenVars -notcontains $Var.Name) {
            $sessionstate.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList $Var.name,$Var.Value,$Var.description,$Var.options,$Var.attributes))
            }
        }

        # Add Functions from current runspace to the InitialSessionState
        ForEach($Function in (Get-ChildItem Function:)) {
            $sessionState.Commands.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList $Function.Name, $Function.Definition))
        }
     
        # threading adapted from
        # https://github.com/darkoperator/Posh-SecMod/blob/master/Discovery/Discovery.psm1#L407
        # Thanks Carlos!   
        $counter = 0

        # create a pool of maxThread runspaces   
        $pool = [runspacefactory]::CreateRunspacePool(1, $MaxThreads, $sessionState, $host)
        $pool.Open()
        $jobs = @()   
        $ps = @()   
        $wait = @()
    }

    process {

        # different script blocks to thread depending on what's passed
        if ($ShareList){
            foreach ($share in $shares){  

                $counter = $counter + 1

                # make sure we get a share name
                if ($share -ne ''){
                    Write-Verbose "[*] Enumerating share $share ($counter of $($shares.count))"

                    While ($($pool.GetAvailableRunspaces()) -le 0) {
                        Start-Sleep -milliseconds 500
                    }
            
                    # create a "powershell pipeline runner"   
                    $ps += [powershell]::create()
           
                    $ps[$counter].runspacepool = $pool

                    # add the server script block + arguments
                    [void]$ps[$counter].AddScript($EnumShareBlock).AddParameter('Share', $Share).AddParameter('Terms', $Terms).AddParameter('ExcludeFolders', $ExcludeFolders).AddParameter('ExcludeHidden', $ExcludeHidden).AddParameter('FreshEXES', $FreshEXES).AddParameter('OfficeDocs', $OfficeDocs).AddParameter('CheckWriteAccess', $CheckWriteAccess).AddParameter('OutFile', $OutFile)

                    # start job
                    $jobs += $ps[$counter].BeginInvoke();
             
                    # store wait handles for WaitForAll call   
                    $wait += $jobs[$counter].AsyncWaitHandle
                }
            }
        }
        else{
            if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
                Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
                $Hosts = Get-NetComputers -Domain $targetDomain
            }
            
            # randomize the host list
            $Hosts = Get-ShuffledArray $Hosts

            foreach ($server in $Hosts){     
                
                $counter = $counter + 1

                # make sure we get a server name
                if ($server -ne ''){
                    Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"

                    While ($($pool.GetAvailableRunspaces()) -le 0) {
                        Start-Sleep -milliseconds 500
                    }
            
                    # create a "powershell pipeline runner"   
                    $ps += [powershell]::create()
           
                    $ps[$counter].runspacepool = $pool

                    # add the server script block + arguments
                   [void]$ps[$counter].AddScript($EnumServerBlock).AddParameter('Server', $server).AddParameter('Ping', -not $NoPing).AddParameter('excludedShares', $excludedShares).AddParameter('Terms', $Terms).AddParameter('ExcludeFolders', $ExcludeFolders).AddParameter('OfficeDocs', $OfficeDocs).AddParameter('ExcludeHidden', $ExcludeHidden).AddParameter('FreshEXES', $FreshEXES).AddParameter('CheckWriteAccess', $CheckWriteAccess).AddParameter('OutFile', $OutFile)
                    
                    # start job
                    $jobs += $ps[$counter].BeginInvoke();
             
                    # store wait handles for WaitForAll call   
                    $wait += $jobs[$counter].AsyncWaitHandle

                }
            }
        }
    }

    end {
        Write-Verbose "Waiting for scanning threads to finish..."

        $waitTimeout = Get-Date

        while ($($jobs | ? {$_.IsCompleted -eq $false}).count -gt 0 -or $($($(Get-Date) - $waitTimeout).totalSeconds) -gt 60) {
                Start-Sleep -milliseconds 500
            } 

        # end async call   
        for ($y = 0; $y -lt $counter; $y++) {     

            try {   
                # complete async job   
                $ps[$y].EndInvoke($jobs[$y])   

            } catch {
                Write-Warning "error: $_"  
            }
            finally {
                $ps[$y].Dispose()
            }    
        }

        $pool.Dispose()
    }
}


function Invoke-FindLocalAdminAccess {
    <#
        .SYNOPSIS
        Finds machines on the local domain where the current user has
        local administrator access.

        Idea stolen from the local_admin_search_enum post module in 
        Metasploit written by:
            'Brandon McCann "zeknox" <bmccann[at]accuvant.com>'
            'Thomas McCarthy "smilingraccoon" <smilingraccoon[at]gmail.com>'
            'Royce Davis "r3dy" <rdavis[at]accuvant.com>'

        Author: @harmj0y
        License: BSD 3-Clause

        .DESCRIPTION
        This function finds the local domain name for a host using Get-NetDomain,
        queries the domain for all active machines with Get-NetComputers, then for 
        each server it checks if the current user has local administrator
        access using Invoke-CheckLocalAdminAccess.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER Delay
        Delay between enumerating hosts, defaults to 0

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.
        
        .PARAMETER Jitter
        Jitter for the host delay, defaults to +/- 0.3
        
        .PARAMETER Domain
        Domain to query for machines

        .EXAMPLE
        > Invoke-FindLocalAdminAccess
        Find machines on the local domain where the current user has local 
        administrator access.

        .EXAMPLE
        > Invoke-FindLocalAdminAccess -Domain testing
        Find machines on the 'testing' domain where the current user has 
        local administrator access.

        .EXAMPLE
        > Invoke-FindLocalAdminAccess -Delay 60
        Find machines on the local domain where the current user has local administrator
        access with a 60 second (+/- *.3) randomized delay between touching each host.

        .EXAMPLE
        > Invoke-FindLocalAdminAccess -HostList hosts.txt
        Find which machines in the host list the current user has local 
        administrator access.

        .LINK
        https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/local_admin_search_enum.rb
        http://www.harmj0y.net/blog/penetesting/finding-local-admin-with-the-veil-framework/
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [Switch]
        $NoPing,
        
        [UInt32]
        $Delay = 0,
        
        [double]
        $Jitter = .3,
        
        [string]
        $Domain
    )

    begin {
    
        If ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # get the current user
        $CurrentUser = Get-NetCurrentUser
        
        # random object for delay
        $randNo = New-Object System.Random
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }

        Write-Verbose "[*] Running Invoke-FindLocalAdminAccess with delay of $Delay"
        if($targetDomain){
            Write-Verbose "[*] Domain: $targetDomain"
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }

    }
        
    process {

        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
 
        $counter = 0
        
        foreach ($server in $Hosts){
            
            $counter = $counter + 1
            
            Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"

            # sleep for our semi-randomized interval
            Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
            
            $up = $true
            if(-not $NoPing){
                $up = Test-Server -Server $server
            }
            if($up){
                # check if the current user has local admin access to this server
                $access = Invoke-CheckLocalAdminAccess -HostName $server
                if ($access) {
                    $ip = Get-HostIP -hostname $server
                    Write-Verbose "[+] Current user '$CurrentUser' has local admin access on $server ($ip)"
                    $server
                }
            }
        }
    }
}


function Invoke-FindLocalAdminAccessThreaded {
    <#
        .SYNOPSIS
        Finds machines on the local domain where the current user has
        local administrator access.
        Threaded version of Invoke-FindLocalAdminAccess.

        Idea stolen from the local_admin_search_enum post module in 
        Metasploit written by:
            'Brandon McCann "zeknox" <bmccann[at]accuvant.com>'
            'Thomas McCarthy "smilingraccoon" <smilingraccoon[at]gmail.com>'
            'Royce Davis "r3dy" <rdavis[at]accuvant.com>'

        Author: @harmj0y
        License: BSD 3-Clause

        .DESCRIPTION
        This function finds the local domain name for a host using Get-NetDomain,
        queries the domain for all active machines with Get-NetComputers, then for 
        each server it checks if the current user has local administrator
        access using Invoke-CheckLocalAdminAccess.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.
        
        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.
        
        .PARAMETER Domain
        Domain to query for machines

        .PARAMETER MaxThreads
        The maximum concurrent threads to execute.

        .EXAMPLE
        > Invoke-FindLocalAdminAccess
        Find machines on the local domain where the current user has local 
        administrator access.

        .EXAMPLE
        > Invoke-FindLocalAdminAccess -Domain testing
        Find machines on the 'testing' domain where the current user has 
        local administrator access.

        .EXAMPLE
        > Invoke-FindLocalAdminAccess -HostList hosts.txt
        Find which machines in the host list the current user has local 
        administrator access.

        .LINK
        https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/local_admin_search_enum.rb
        http://www.harmj0y.net/blog/penetesting/finding-local-admin-with-the-veil-framework/
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [Switch]
        $NoPing,

        [string]
        $Domain,

        [Int]
        $MaxThreads=10
    )
    
    begin {
        If ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # get the current user
        $CurrentUser = Get-NetCurrentUser
        
        # random object for delay
        $randNo = New-Object System.Random
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }

        Write-Verbose "[*] Running Invoke-FindLocalAdminAccessThreaded with delay of $Delay"
        if($targetDomain){
            Write-Verbose "[*] Domain: $targetDomain"
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }
        
        # script block that eunmerates a server
        # this is called by the multi-threading code later
        $EnumServerBlock = {
            param($Server, $Ping, $CurrentUser)

            $up = $true
            if($Ping){
                $up = Test-Server -Server $server
            }
            if($up){
                # check if the current user has local admin access to this server
                $access = Invoke-CheckLocalAdminAccess -HostName $server
                if ($access) {
                    $ip = Get-HostIP -hostname $server
                    Write-Verbose "[+] Current user '$CurrentUser' has local admin access on $server ($ip)"
                    $server
                }
            }
        }

        # Adapted from:
        #   http://powershell.org/wp/forums/topic/invpke-parallel-need-help-to-clone-the-current-runspace/
        $sessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
        $sessionState.ApartmentState = [System.Threading.Thread]::CurrentThread.GetApartmentState()
     
        # grab all the current variables for this runspace
        $MyVars = Get-Variable -Scope 1
     
        # these Variables are added by Runspace.Open() Method and produce Stop errors if you add them twice
        $VorbiddenVars = @("?","args","ConsoleFileName","Error","ExecutionContext","false","HOME","Host","input","InputObject","MaximumAliasCount","MaximumDriveCount","MaximumErrorCount","MaximumFunctionCount","MaximumHistoryCount","MaximumVariableCount","MyInvocation","null","PID","PSBoundParameters","PSCommandPath","PSCulture","PSDefaultParameterValues","PSHOME","PSScriptRoot","PSUICulture","PSVersionTable","PWD","ShellId","SynchronizedHash","true")
     
        # Add Variables from Parent Scope (current runspace) into the InitialSessionState 
        ForEach($Var in $MyVars) {
            If($VorbiddenVars -notcontains $Var.Name) {
            $sessionstate.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList $Var.name,$Var.Value,$Var.description,$Var.options,$Var.attributes))
            }
        }

        # Add Functions from current runspace to the InitialSessionState
        ForEach($Function in (Get-ChildItem Function:)) {
            $sessionState.Commands.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList $Function.Name, $Function.Definition))
        }
     
        # threading adapted from
        # https://github.com/darkoperator/Posh-SecMod/blob/master/Discovery/Discovery.psm1#L407
        # Thanks Carlos!   
        $counter = 0

        # create a pool of maxThread runspaces   
        $pool = [runspacefactory]::CreateRunspacePool(1, $MaxThreads, $sessionState, $host)
        $pool.Open()

        $jobs = @()   
        $ps = @()   
        $wait = @()

        $counter = 0
    }

    process {

        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
        $HostCount = $Hosts.Count
        Write-Verbose "[*] Total number of hosts: $HostCount"

        foreach ($server in $Hosts){
            
            $counter = $counter + 1            
            
            # make sure we get a server name
            if ($server -ne ''){
                Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"

                While ($($pool.GetAvailableRunspaces()) -le 0) {
                    Start-Sleep -milliseconds 500
                }
        
                # create a "powershell pipeline runner"   
                $ps += [powershell]::create()
       
                $ps[$counter].runspacepool = $pool

                # add the script block + arguments
                [void]$ps[$counter].AddScript($EnumServerBlock).AddParameter('Server', $server).AddParameter('Ping', -not $NoPing).AddParameter('CurrentUser', $CurrentUser)
        
                # start job
                $jobs += $ps[$counter].BeginInvoke();
         
                # store wait handles for WaitForAll call   
                $wait += $jobs[$counter].AsyncWaitHandle

            }
        }
    }

    end {
        Write-Verbose "Waiting for scanning threads to finish..."

        $waitTimeout = Get-Date

        while ($($jobs | ? {$_.IsCompleted -eq $false}).count -gt 0 -or $($($(Get-Date) - $waitTimeout).totalSeconds) -gt 60) {
                Start-Sleep -milliseconds 500
            } 

        # end async call   
        for ($y = 0; $y -lt $counter; $y++) {     

            try {   
                # complete async job   
                $ps[$y].EndInvoke($jobs[$y])   

            } catch {
                Write-Warning "error: $_"  
            }
            finally {
                $ps[$y].Dispose()
            }    
        }

        $pool.Dispose()
    }
}


function Invoke-UserFieldSearch {
    <#
        .SYNOPSIS
        Searches user object fields for a given word (default *pass*). Default
        field being searched is 'description'.

        .DESCRIPTION
        This function queries all users in the domain with Get-NetUser,
        extracts all the specified field(s) and searches for a given
        term, default "*pass*". Case is ignored.

        .PARAMETER Field
        User field to search in, default of "description".

        .PARAMETER Term
        Term to search for, default of "pass"

        .PARAMETER Domain
        Domain to search user fields for.

        .EXAMPLE
        > Invoke-UserFieldSearch
        Find user accounts with "pass" in the description.

        .EXAMPLE
        > Invoke-UserFieldSearch -Field info -Term backup
        Find user accounts with "backup" in the "info" field.
    #>
    
    [CmdletBinding()]
    param(
        [string]
        $Field = 'description',

        [string]
        $Term = 'pass',
        
        [string]
        $Domain
    )
    
    if ($Domain){
        $users = Get-NetUser -Domain $Domain
    }
    else{
        $users = Get-NetUser
    }
    
    foreach ($user in $users){
        
        $desc = $user.($Field)
        
        if ($desc){
            $desc = $desc[0].ToString().ToLower()
        }
        if ( ($desc -ne $null) -and ($desc.Contains($Term.ToLower())) ){
            $u = $user.samaccountname[0]
            $out = New-Object System.Collections.Specialized.OrderedDictionary
            $out.add('User', $u)
            $out.add($Field, $desc)
            $out
        }
    }
}


function Invoke-ComputerFieldSearch {
    <#
        .SYNOPSIS
        Searches computer object fields for a given word (default *pass*). Default
        field being searched is 'description'.

        .PARAMETER Field
        User field to search in, default of "description".

        .PARAMETER Term
        Term to search for, default of "pass".

        .PARAMETER Domain
        Domain to search computer fields for.

        .EXAMPLE
        > Invoke-ComputerFieldSearch
        Find computer accounts with "pass" in the description.

        .EXAMPLE
        > Invoke-ComputerFieldSearch -Field info -Term backup
        Find computer accounts with "backup" in the "info" field.
    #>
    
    [CmdletBinding()]
    param(
        [string]
        $Field = 'description',

        [string]
        $Term = 'pass',

        [string]
        $Domain
    )
    
    # if a domain is specified, try to grab that domain
    if ($Domain){
        # try to grab the primary DC for the current domain
        try{
            $PrimaryDC = ([Array](Get-NetDomainControllers))[0].Name
        }
        catch{
            $PrimaryDC = $Null
        }

        try {
            $dn = "DC=$($Domain.Replace('.', ',DC='))"

            # if we could grab the primary DC for the current domain, use that for the query
            if($PrimaryDC){
                $CompSearcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]"LDAP://$PrimaryDC/$dn")
            }
            else{
                # otherwise try to connect to the DC for the target domain
                $CompSearcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]"LDAP://$dn") 
            }
            $CompSearcher.filter='(&(objectClass=Computer))'
            
        }
        catch{
            Write-Warning "The specified domain $Domain does not exist, could not be contacted, or there isn't an existing trust."
        }
    }
    else{
        $CompSearcher = [adsisearcher]'(&(objectClass=Computer))'
    }
    
    if ($CompSearcher){
        
        # eliminate that pesky 1000 system limit
        $CompSearcher.PageSize = 200
        
        $CompSearcher.FindAll() | ForEach-Object {
            
            $desc = $_.Properties.$Field
            
            if ($desc){
                $desc = $desc[0].ToString().ToLower()
            }
            if ( ($desc -ne $null) -and ($desc.Contains($Term.ToLower())) ){
                $c = $_.Properties.name
                $out = New-Object System.Collections.Specialized.OrderedDictionary
                $out.add('Computer', $c)
                $out.add($Field, $desc)
                $out
            }
        }
    }
    
}


function Invoke-FindVulnSystems {
    <#
        .SYNOPSIS
        Finds systems that are likely vulnerable to MS08-067

        .DESCRIPTION
        This function queries all users in the domain with Get-NetComputers,
        and extracts Windows 2000, Windows XP SP1/2, and Windows 2003 SP1 objects.

        .PARAMETER FullData
        Return full user computer objects instead of just system names (the default)

        .PARAMETER Ping
        Ping hosts and only return those that are up/responding.

        .PARAMETER Domain
        Domain to query for systems.

        .EXAMPLE
        > Invoke-FindVulnSystems
        Return the host names of systems likely vulnerable to MS08-067

        .EXAMPLE
        > Invoke-FindVulnSystems -Domain testing
        Return the host names of systems likely vulnerable to MS08-067
        on the 'testing' domain

        .EXAMPLE
        > Invoke-FindVulnSystems -FullData
        Return the full system objects likely vulnerable to MS08-067
    #>
    
    [CmdletBinding()]
    param(
        [Switch]
        $FullData,

        [Switch]
        $Ping,

        [string]
        $Domain
    )
    
    # get the target domain
    if($Domain){
        $targetDomain = $Domain
    }
    else{
        # use the local domain
        $targetDomain = $null
    }
    
    # get all servers with full data in the domain
    $servers = Get-NetComputers -FullData $targetDomain
    
    # find any windows 2000 boxes
    $vuln2000 = $servers | Where-Object {$_.OperatingSystem -match '.*2000.*'}
    
    # find any windows XP boxes, excluding SP3
    $vulnXP = $servers | Where-Object {$_.OperatingSystem -match '.*XP.*' -and $_.ServicePack -notmatch '.*3.*'}
    
    # find any windows 2003 SP1 boxes
    $vuln2003 = $servers | Where-Object {$_.OperatingSystem -match '.*2003.*' -and $_.ServicePack -match '.*1.*'}
    
    
    if ($FullData){
        if($Ping){
            if ($vuln2000) { $vuln2000 | Where-Object { Test-Server -Server $_.HostName } }
            if ($vulnXP) { $vulnXP | Where-Object { Test-Server -Server $_.HostName } }
            if ($vuln2003) { $vuln2003 | Where-Object { Test-Server -Server $_.HostName } }
        }
        else{
            $vuln2000 
            $vulnXP
            $vuln2003
        }
    }
    else{
        if($Ping){
            if($vuln2000) { $vuln2000 | Where-Object {Test-Server -Server $_.HostName} | ForEach-Object {$_.HostName} }
            if($vulnXP) { $vulnXP | Where-Object {Test-Server -Server $_.HostName} | ForEach-Object {$_.HostName} }
            if($vuln2003) { $vuln2003 | Where-Object {Test-Server -Server $_.HostName} | ForEach-Object {$_.HostName} }
        }
        else {
            $vuln2000 | ForEach-Object {$_.HostName}
            $vulnXP | ForEach-Object {$_.HostName}
            $vuln2003 | ForEach-Object {$_.HostName}
        }
    }
}


function Invoke-EnumerateLocalAdmins {
    <#
        .SYNOPSIS
        Enumerates members of the local Administrators groups
        across all machines in the domain.

        Author: @harmj0y
        License: BSD 3-Clause

        .DESCRIPTION
        This function queries the domain for all active machines with 
        Get-NetComputers, then for each server it queries the local
        Administrators with Get-NetLocalGroup.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.

        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER Delay
        Delay between enumerating hosts, defaults to 0.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.
        
        .PARAMETER Jitter
        Jitter for the host delay, defaults to +/- 0.3.

        .PARAMETER OutFile
        Output results to a specified csv output file.

        .PARAMETER Domain
        Domain to query for systems.

        .LINK
        http://blog.harmj0y.net/
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,
      
        [Switch]
        $NoPing,
        
        [UInt32]
        $Delay = 0,
        
        [double]
        $Jitter = .3,
        
        [string]
        $OutFile,
        
        [string]
        $Domain
    )
    
    begin {

        If ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        Write-Verbose "[*] Running Invoke-EnumerateLocalAdmins with delay of $Delay"
        if($targetDomain){
            Write-Verbose "[*] Domain: $targetDomain"
        }

        # random object for delay
        $randNo = New-Object System.Random
        
        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }

        # delete any existing output file if it already exists
        If ($OutFile -and (Test-Path -Path $OutFile)){ Remove-Item -Path $OutFile }

    }

    process{

        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
 
        $counter = 0
        
        foreach ($server in $Hosts){
            
            $counter = $counter + 1
            
            Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"
            
            # sleep for our semi-randomized interval
            Start-Sleep -Seconds $randNo.Next((1-$Jitter)*$Delay, (1+$Jitter)*$Delay)
            
            $up = $true
            if(-not $NoPing){
                $up = Test-Server -Server $server
            }
            if($up){
                # grab the users for the local admins on this server
                $users = Get-NetLocalGroup -HostName $server
                if($users -and ($users.Length -ne 0)){
                    # output the results to a csv if specified
                    if($OutFile){
                        $users | export-csv -Append -notypeinformation -path $OutFile
                    }
                    else{
                        # otherwise return the user objects
                        $users
                    }
                }
                else{
                    Write-Verbose "[!] No users returned from $server"
                }
            }   
        }
    }
}


function Invoke-EnumerateLocalAdminsThreaded {
    <#
        .SYNOPSIS
        Enumerates members of the local Administrators groups
        across all machines in the domain.

        Author: @harmj0y
        License: BSD 3-Clause
     
        .DESCRIPTION
        This function queries the domain for all active machines with 
        Get-NetComputers, then for each server it queries the local
        Administrators with Get-NetLocalGroup.

        .PARAMETER Hosts
        Host array to enumerate, passable on the pipeline.

        .PARAMETER HostList
        List of hostnames/IPs to search.
      
        .PARAMETER HostFilter
        Host filter name to query AD for, wildcards accepted.

        .PARAMETER NoPing
        Don't ping each host to ensure it's up before enumerating.

        .PARAMETER Domain
        Domain to query for systems.

        .PARAMETER MaxThreads
        The maximum concurrent threads to execute.

        .LINK
        http://blog.harmj0y.net/
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Position=0,ValueFromPipeline=$true)]
        [String[]]
        $Hosts,

        [string]
        $HostList,

        [string]
        $HostFilter,

        [Switch]
        $NoPing,
        
        [string]
        $Domain,

        [Int]
        $MaxThreads = 10
    )
    
    begin {
        If ($PSBoundParameters['Debug']) {
            $DebugPreference = 'Continue'
        }
        
        # get the target domain
        if($Domain){
            $targetDomain = $Domain
        }
        else{
            # use the local domain
            $targetDomain = $null
        }
        
        Write-Verbose "[*] Running Invoke-EnumerateLocalAdminsThreaded with delay of $Delay"
        if($targetDomain){
            Write-Verbose "[*] Domain: $targetDomain"
        }

        # if we're using a host list, read the targets in and add them to the target list
        if($HostList){
            if (Test-Path -Path $HostList){
                $Hosts = Get-Content -Path $HostList
            }
            else{
                Write-Warning "[!] Input file '$HostList' doesn't exist!"
                "[!] Input file '$HostList' doesn't exist!"
                return
            }
        }
        elseif($HostFilter){
            Write-Verbose "[*] Querying domain $targetDomain for hosts with filter '$HostFilter'`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain -HostName $HostFilter
        }

        # script block that eunmerates a server
        # this is called by the multi-threading code later
        $EnumServerBlock ={
            param($Server, $Ping)

            # optionally check if the server is up first
            $up = $true
            if($Ping){
                $up = Test-Server -Server $Server
            }
            if($up){
                # grab the users for the local admins on this server
                $users = Get-NetLocalGroup -HostName $server
                if($users -and ($users.Length -ne 0)){
                    $users
                }
                else{
                    Write-Verbose "[!] No users returned from $server"
                }
            }
        }

            # Adapted from:
        #   http://powershell.org/wp/forums/topic/invpke-parallel-need-help-to-clone-the-current-runspace/
        $sessionState = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
        $sessionState.ApartmentState = [System.Threading.Thread]::CurrentThread.GetApartmentState()
     
        # grab all the current variables for this runspace
        $MyVars = Get-Variable -Scope 1
     
        # these Variables are added by Runspace.Open() Method and produce Stop errors if you add them twice
        $VorbiddenVars = @("?","args","ConsoleFileName","Error","ExecutionContext","false","HOME","Host","input","InputObject","MaximumAliasCount","MaximumDriveCount","MaximumErrorCount","MaximumFunctionCount","MaximumHistoryCount","MaximumVariableCount","MyInvocation","null","PID","PSBoundParameters","PSCommandPath","PSCulture","PSDefaultParameterValues","PSHOME","PSScriptRoot","PSUICulture","PSVersionTable","PWD","ShellId","SynchronizedHash","true")
     
        # Add Variables from Parent Scope (current runspace) into the InitialSessionState 
        ForEach($Var in $MyVars) {
            If($VorbiddenVars -notcontains $Var.Name) {
            $sessionstate.Variables.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateVariableEntry -ArgumentList $Var.name,$Var.Value,$Var.description,$Var.options,$Var.attributes))
            }
        }

        # Add Functions from current runspace to the InitialSessionState
        ForEach($Function in (Get-ChildItem Function:)) {
            $sessionState.Commands.Add((New-Object -TypeName System.Management.Automation.Runspaces.SessionStateFunctionEntry -ArgumentList $Function.Name, $Function.Definition))
        }
     
        # threading adapted from
        # https://github.com/darkoperator/Posh-SecMod/blob/master/Discovery/Discovery.psm1#L407
        # Thanks Carlos!   
        $counter = 0

        # create a pool of maxThread runspaces   
        $pool = [runspacefactory]::CreateRunspacePool(1, $MaxThreads, $sessionState, $host)
        $pool.Open()

        $jobs = @()   
        $ps = @()   
        $wait = @()

        $counter = 0
    }

    process {

        if ( (-not ($Hosts)) -or ($Hosts.length -eq 0)) {
            Write-Verbose "[*] Querying domain $targetDomain for hosts...`r`n"
            $Hosts = Get-NetComputers -Domain $targetDomain
        }
        
        # randomize the host list
        $Hosts = Get-ShuffledArray $Hosts
        $HostCount = $Hosts.Count
        Write-Verbose "[*] Total number of hosts: $HostCount"

        foreach ($server in $Hosts){
            
            $counter = $counter + 1
            
            # make sure we get a server name
            if ($server -ne ''){
                Write-Verbose "[*] Enumerating server $server ($counter of $($Hosts.count))"

                While ($($pool.GetAvailableRunspaces()) -le 0) {
                    Start-Sleep -milliseconds 500
                }
        
                # create a "powershell pipeline runner"   
                $ps += [powershell]::create()
       
                $ps[$counter].runspacepool = $pool

                # add the script block + arguments
                [void]$ps[$counter].AddScript($EnumServerBlock).AddParameter('Server', $server).AddParameter('Ping', -not $NoPing)
        
                # start job
                $jobs += $ps[$counter].BeginInvoke();
         
                # store wait handles for WaitForAll call   
                $wait += $jobs[$counter].AsyncWaitHandle
            }
        }
    }

    end {

        Write-Verbose "Waiting for scanning threads to finish..."

        $waitTimeout = Get-Date

        while ($($jobs | ? {$_.IsCompleted -eq $false}).count -gt 0 -or $($($(Get-Date) - $waitTimeout).totalSeconds) -gt 60) {
                Start-Sleep -milliseconds 500
            } 

        # end async call   
        for ($y = 0; $y -lt $counter; $y++) {     

            try {   
                # complete async job   
                $ps[$y].EndInvoke($jobs[$y])   

            } catch {
                Write-Warning "error: $_"  
            }
            finally {
                $ps[$y].Dispose()
            }    
        }
        $pool.Dispose()
    }
}


function Invoke-HostEnum {
    <#
        .SYNOPSIS
        Runs all available enumeration methods on a given host.

        .DESCRIPTION
        This function runs all available functions on a given host,
        including querying AD for host information, finding active
        sessions on a host, logged on users, available shares, whether
        the current user has local admin access, the local groups,
        local administrators, and local services on the target.

        .PARAMETER HostName
        The hostname to enumerate.

        .EXAMPLE
        > Invoke-HostEnum WINDOWSXP
        Runs all enumeration methods on the WINDOWSXP host
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $True)]
        [string]
        $HostName
    )
    
    If ($PSBoundParameters['Debug']) {
        $DebugPreference = 'Continue'
    }
    
    "[+] Invoke-HostEnum Report: $HostName"
    
    # Step 1: get any AD data associated with this server
    $adinfo = Get-NetComputers -Hostname "$HostName*" -FullData | Out-String
    "`n[+] AD query for: $HostName"
     $adinfo.Trim()
    
    # Step 2: get active sessions for this host and display what we find
    $sessions = Get-NetSessions -HostName $HostName
    if ($sessions -and ($sessions.Count -ne 0)){
        "`n[+] Active sessions for $HostName :"
    }
    foreach ($session in $sessions) {
        $username = $session.sesi10_username
        $cname = $session.sesi10_cname
        $activetime = $session.sesi10_time
        $idletime = $session.sesi10_idle_time
        # make sure we have a result
        if (($username -ne $null) -and ($username.trim() -ne '')){
            "[+] $HostName - Session - $username from $cname - Active: $activetime - Idle: $idletime"
        }
    }
    
    # Step 3: get any logged on users for this host and display what we find
    $users = Get-NetLoggedon -HostName $HostName
    if ($users -and ($users.Count -ne 0)){
        "`n[+] Users logged onto $HostName :"
    }
    foreach ($user in $users) {
        $username = $user.wkui1_username
        $domain = $user.wkui1_logon_domain
        
        if ($username -ne $null){
            # filter out $ machine accounts
            if ( !$username.EndsWith("$") ) {
                "[+] $HostName - Logged-on - $domain\\$username"
            }
        }
    }
    
    # step 4: see if we can get the last loggedon user by remote registry
    $lastUser = Get-LastLoggedOn -HostName $HostName
    if ($lastUser){
        "`n[+] Last user logged onto $HostName : $lastUser"
    }
    
    # Step 5: get the shares for this host and display what we find
    $shares = Get-NetShare -HostName $HostName
    if ($shares -and ($shares.Count -ne 0)){
        "`n[+] Shares on $HostName :"
    }
    foreach ($share in $shares) {
        if ($share -ne $null){
            $netname = $share.shi1_netname
            $remark = $share.shi1_remark
            $path = '\\'+$HostName+'\'+$netname
            
            if (($netname) -and ($netname.trim() -ne '')){
                
                "[+] $HostName - Share: $netname `t: $remark"
                try{
                    # check for read access to this share
                    $f=[IO.Directory]::GetFiles($path)
                    "[+] $HostName - Read Access - Share: $netname `t: $remark"
                }
                catch {}
            }
        }
    }
    
    # Step 6: Check if current user has local admin access
    $access = Invoke-CheckLocalAdminAccess -Hostname $HostName
    if ($access){
        "`n[+] Current user has local admin access to $HostName !"
    }
    
    # Step 7: Get all the local groups
    $localGroups = Get-NetLocalGroups -Hostname $HostName | Format-List | Out-String
    if ($localGroups -and $localGroups.Length -ne 0){
        "`n[+] Local groups for $HostName :"
        $localGroups.Trim()
    }
    else {
        "[!] Unable to retrieve localgroups for $HostName"
    }
    
    # Step 8: Get any local admins
    $localAdmins = Get-NetLocalGroup -Hostname $HostName | Format-List | Out-String
    if ($localAdmins -and $localAdmins.Length -ne 0){
        "`n[+] Local Administrators for $HostName :"
        $localAdmins.Trim()
    }
    else {
        "[!] Unable to retrieve local Administrators for $HostName"
    }
    
    # Step 9: Get any local services
    $localServices = Get-NetLocalServices -Hostname $HostName | Format-List | Out-String
    if ($localServices -and $localServices.Length -ne 0){
        "`n[+] Local services for $HostName :"
        $localServices.Trim()
    }
    else {
        "[!] Unable to retrieve local services for $HostName"
    }

    # Step 10: Enumerate running processes
    $processes = Get-NetProcesses -Hostname $HostName
    if ($processes){
        "`n[+] Processes for $HostName :"
        $processes | Format-Table -AutoSize
    }
    else {
        "[!] Unable to retrieve processes for $HostName"
    }
}


########################################################
#
# Domain trust functions below.
#
########################################################

function Get-NetDomainTrusts {
    <#
        .SYNOPSIS
        Return all domain trusts for the current domain or
        a specified domain.

        .PARAMETER Domain
        The domain whose trusts to enumerate. If not given, 
        uses the current domain.

        .EXAMPLE
        > Get-NetDomainTrusts
        Return domain trusts for the current domain.

        .EXAMPLE
        > Get-NetDomainTrusts -Domain "test"
        Return domain trusts for the "test" domain.  
    #>

    [CmdletBinding()]
    param(
        [string]
        $Domain
    )
    
    # if a domain is specified, try to grab that domain
    if ($Domain){
        
        try{
            # try to create the context for the target domain
            $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $Domain)
            [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext).GetAllTrustRelationships()
        }
        catch{
            Write-Warning "The specified domain $Domain does not exist, could not be contacted, or there isn't an existing trust."
            $null
        }
    }
    else{
        # otherwise, grab the current domain
        [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().GetAllTrustRelationships()
    }
}


function Get-NetDomainTrustsLDAP {
    <#
        .SYNOPSIS
        Return all domain trusts for the current domain or
        a specified domain using LDAP queries. This is potentially
        less accurate than the Get-NetDomainTrusts function, but
        can be relayed through your current domain controller
        in cases where you can't reach a remote domain directly.

        .PARAMETER Domain
        The domain whose trusts to enumerate. If not given, 
        uses the current domain.

        .EXAMPLE
        > Get-NetDomainTrustsLDAP
        Return domain trusts for the current domain.

        .EXAMPLE
        > Get-NetDomainTrustsLDAP -Domain "test"
        Return domain trusts for the "test" domain.  
    #>

    [CmdletBinding()]
    param(
        [string]
        $Domain
    )

    $TrustSearcher = $Null

    # if a domain is specified, try to grab that domain
    if ($Domain){

        # try to grab the primary DC for the current domain
        try{
            $PrimaryDC = ([Array](Get-NetDomainControllers))[0].Name
        }
        catch{
            $PrimaryDC = $Null
        }

        try {
            # reference - http://blogs.msdn.com/b/javaller/archive/2013/07/29/searching-across-active-directory-domains-in-powershell.aspx
            $dn = "DC=$($Domain.Replace('.', ',DC='))"

            # if we could grab the primary DC for the current domain, use that for the query
            if ($PrimaryDC){
                $TrustSearcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]"LDAP://$PrimaryDC/$dn")
            }
            else{
                # otherwise default to connecting to the DC for the target domain
                $TrustSearcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]"LDAP://$dn")
            }
            
            $TrustSearcher.filter = '(&(objectClass=trustedDomain))'
            $TrustSearcher.PageSize = 200
        }
        catch{
            Write-Warning "The specified domain $Domain does not exist, could not be contacted, or there isn't an existing trust."
            $TrustSearcher = $Null
        }
    }
    else{
        $Domain = Get-NetDomain
        $TrustSearcher = [adsisearcher]'(&(objectClass=trustedDomain))'
        $TrustSearcher.PageSize = 200
    }

    if($TrustSearcher){
        $TrustSearcher.FindAll() | ForEach-Object {
            $props = $_.Properties
            $out = New-Object psobject
            Switch ($props.trustattributes) 
            { 
                16 { $attrib = "CrossLink"} 
                32 { $attrib = "ParentChild"} 
                64 { $attrib = "External"} 
                68 { $attrib = "ExternalQuarantined"} 
                Default { $attrib = "unknown trust attribute number: $($props.trustattributes)" }
            } 
            Switch ($props.trustdirection){
                0 {$direction = "Disabled"}
                1 {$direction = "Inbound"}
                2 {$direction = "Outbound"}
                3 {$direction = "Bidirectional"}
            }
            $out | Add-Member Noteproperty 'SourceName' $domain
            $out | Add-Member Noteproperty 'TargetName' $props.name[0]
            $out | Add-Member Noteproperty 'TrustType' $attrib
            $out | Add-Member Noteproperty 'TrustDirection' $direction
            $out 
        }
    }
}


function Get-NetForestTrusts {
    <#
        .SYNOPSIS
        Return all trusts for the current forest.

        .PARAMETER Forest
        Return trusts for the specified forest.

        .EXAMPLE
        > Get-NetForestTrusts
        Return current forest trusts.

        .EXAMPLE
        > Get-NetForestTrusts -Forest "test"
        Return trusts for the "test" forest.
    #>

    [CmdletBinding()]
    param(
        [string]
        $Forest
    )

    $f = (Get-NetForest -Forest $Forest)
    if($f){
        $f.GetAllTrustRelationships()
    }
}


function Invoke-FindUserTrustGroups {
    <#
        .SYNOPSIS
        Enumerates users who are in groups outside of their
        principal domain.
        
        .DESCRIPTION
        This function queries the domain for all users objects,
        extract the memberof groups for each users, and compares
        found memberships to the user's current domain.
        Any group memberships outside of the current domain
        are output.

        .PARAMETER UserName
        Username to filter results for, wilfcards accepted.

        .PARAMETER Domain
        Domain to query for users.

        .LINK
        http://blog.harmj0y.net/
    #>

    [CmdletBinding()]
    param(
        [string]
        $UserName,

        [string]
        $Domain
    )

    if ($Domain){
        # check if we're filtering for a specific user
        if($UserName){
            $users = Get-NetUser -Domain $Domain -UserName $UserName
        }
        else{
            $users = Get-NetUser -Domain $Domain
        }
        # get the domain name into distinguished form
        $DistinguishedDomainName = "DC=" + $Domain -replace '\.',',DC='
    }
    else {
        # check if we're filtering for a specific user
        if($UserName){
            $users = Get-NetUser -UserName $UserName
        }
        else{
            $users = Get-NetUser
        }
        $DistinguishedDomainName = [string] ([adsi]'').distinguishedname
        $Domain = $DistinguishedDomainName -replace 'DC=','' -replace ',','.'
    }

    # check "memberof" for each user
    foreach ($user in $users){

        # get this user's memberships
        $memberships = $user.memberof

        foreach ($membership in $memberships){
            if($membership){
                # extract out just domain containers
                $index = $membership.IndexOf("DC=")
                if($index){
                    $DomainMembership = $membership.substring($index)
                    # if this domain membership isn't the users's pricipal domain, output it
                    if($DomainMembership -ne $DistinguishedDomainName){
                        $out = new-object psobject 
                        $out | add-member Noteproperty 'Domain' $Domain
                        $out | add-member Noteproperty 'User' $user.samaccountname[0]
                        $out | add-member Noteproperty 'GroupMembership' $membership
                        $out
                    }
                }
                
            }
        }
    }
}


function Invoke-MapDomainTrusts {
    <#
        .SYNOPSIS
        Try to map all transitive domain trust relationships.
        
        .DESCRIPTION
        This function gets all trusts for the current domain,
        and tries to get all trusts for each domain it finds.

        .EXAMPLE
        > Invoke-MapDomainTrusts
        Return a "domain1,domain2,trustType,trustDirection" list

        .LINK
        http://blog.harmj0y.net/
    #>

    # keep track of domains seen so we don't hit infinite recursion
    $seenDomains = @{}

    # our domain status tracker
    $domains = New-Object System.Collections.Stack

    # get the current domain and push it onto the stack
    $currentDomain = (([adsi]'').distinguishedname -replace 'DC=','' -replace ',','.')[0]
    $domains.push($currentDomain)

    while($domains.Count -ne 0){

        $d = $domains.Pop()

        # if we haven't seen this domain before
        if (-not $seenDomains.ContainsKey($d)) {

            # mark it as seen in our list
            $seenDomains.add($d, "") | out-null

            try{
                # get all the trusts for this domain
                $trusts = Get-NetDomainTrusts -Domain $d
                if ($trusts){

                    # enumerate each trust found
                    foreach ($trust in $trusts){
                        $source = $trust.SourceName
                        $target = $trust.TargetName
                        $type = $trust.TrustType
                        $direction = $trust.TrustDirection

                        # make sure we process the target
                        $domains.push($target) | out-null

                        # build the nicely-parsable custom output object
                        $out = new-object psobject 
                        $out | add-member Noteproperty 'SourceDomain' $source
                        $out | add-member Noteproperty 'TargetDomain' $target
                        $out | add-member Noteproperty 'TrustType' $type
                        $out | add-member Noteproperty 'TrustDirection' $direction
                        $out
                    }
                }
            }
            catch{
                Write-Warning "[!] Error: $_"
            }
        }
    }
}


function Invoke-MapDomainTrustsLDAP {
    <#
        .SYNOPSIS
        Try to map all transitive domain trust relationships
        through LDAP queries.

        .EXAMPLE
        > Invoke-MapDomainTrustsLDAP
        Return a "domain1,domain2,trustType,trustDirection" list

        .LINK
        http://blog.harmj0y.net/
    #>

    # keep track of domains seen so we don't hit infinite recursion
    $seenDomains = @{}

    # our domain status tracker
    $domains = New-Object System.Collections.Stack

    # get the current domain and push it onto the stack
    $currentDomain = (([adsi]'').distinguishedname -replace 'DC=','' -replace ',','.')[0]
    $domains.push($currentDomain)

    while($domains.Count -ne 0){

        $d = $domains.Pop()

        # if we haven't seen this domain before
        if (-not $seenDomains.ContainsKey($d)) {

            # mark it as seen in our list
            $seenDomains.add($d, "") | out-null

            try{
                # get all the trusts for this domain through LDAP queries
                $trusts = Get-NetDomainTrustsLDAP -Domain $d
                if ($trusts){

                    # enumerate each trust found
                    foreach ($trust in $trusts){
                        $source = $trust.SourceName
                        $target = $trust.TargetName
                        $type = $trust.TrustType
                        $direction = $trust.TrustDirection

                        # make sure we process the target
                        $domains.push($target) | out-null

                        # build the nicely-parsable custom output object
                        $out = new-object psobject 
                        $out | add-member Noteproperty 'SourceDomain' $source
                        $out | add-member Noteproperty 'TargetDomain' $target
                        $out | add-member Noteproperty 'TrustType' $type
                        $out | add-member Noteproperty 'TrustDirection' $direction
                        $out
                    }
                }
            }
            catch{
                Write-Warning "[!] Error: $_"
            }
        }
    }
}


function Invoke-FindAllUserTrustGroups {
    <#
        .SYNOPSIS
        Try to map all transitive domain trust relationships and
        enumerates all users who are in groups outside of their
        principal domain.
        
        .DESCRIPTION
        This function tries to map all domain trusts, and then
        queries the domain for all users objects, extracting the 
        memberof groups for each users, and compares
        found memberships to the user's current domain.
        Any group memberships outside of the current domain
        are output.

        .PARAMETER UserName
        Username to filter results for, wilfcards accepted.

        .LINK
        http://blog.harmj0y.net/
    #>

    [CmdletBinding()]
    param(
        [string]
        $UserName
    )

    # keep track of domains seen so we don't hit infinite recursion
    $seenDomains = @{}

    # our domain status tracker
    $domains = New-Object System.Collections.Stack

    # get the current domain and push it onto the stack
    $currentDomain = (([adsi]'').distinguishedname -replace 'DC=','' -replace ',','.')[0]
    $domains.push($currentDomain)

    while($domains.Count -ne 0){

        $d = $domains.Pop()

        # if we haven't seen this domain before
        if (-not $seenDomains.ContainsKey($d)) {

            # mark it as seen in our list
            $seenDomains.add($d, "") | out-null

            # get the trust groups for this domain
            if ($UserName){
                Invoke-FindUserTrustGroups -Domain $d -UserName $UserName

            }
            else{
                Invoke-FindUserTrustGroups -Domain $d                
            }

            try{
                # get all the trusts for this domain
                $trusts = Get-NetDomainTrusts -Domain $d
                if ($trusts){

                    # enumerate each trust found
                    foreach ($trust in $trusts){
                        $source = $trust.SourceName
                        $target = $trust.TargetName
                        $type = $trust.TrustType
                        $direction = $trust.TrustDirection

                        # make sure we process the target
                        $domains.push($target) | out-null
                    }
                }
            }
            catch{
                Write-Warning "[!] Error: $_"
            }
        }
    }
}


# expose the Win32API functions and datastructures below
# using PSReflect

$Mod = New-InMemoryModule -ModuleName Win32

# all of the Win32 API functions we need
$FunctionDefinitions = @(
    (func netapi32 NetShareEnum ([Int]) @([string], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 NetWkstaUserEnum ([Int]) @([string], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 NetSessionEnum ([Int]) @([string], [string], [string], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),    
    (func netapi32 NetFileEnum ([Int]) @([string], [string], [string], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 NetConnectionEnum ([Int]) @([string], [string], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),
    (func netapi32 NetApiBufferFree ([Int]) @([IntPtr])),
    (func advapi32 OpenSCManagerW ([IntPtr]) @([string], [string], [Int])),
    (func advapi32 CloseServiceHandle ([Int]) @([IntPtr])),
    (func kernel32 GetLastError ([Int]) @())
)

# the NetShareEnum result structure
$SHARE_INFO_1 = struct $Mod SHARE_INFO_1 @{
    shi1_netname = field 0 String -MarshalAs @('LPWStr')
    shi1_type = field 1 UInt32
    shi1_remark = field 2 String -MarshalAs @('LPWStr')
}

# the NetWkstaUserEnum result structure
$WKSTA_USER_INFO_1 = struct $Mod WKSTA_USER_INFO_1 @{
    wkui1_username = field 0 String -MarshalAs @('LPWStr')
    wkui1_logon_domain = field 1 String -MarshalAs @('LPWStr')
    wkui1_oth_domains = field 2 String -MarshalAs @('LPWStr')
    wkui1_logon_server = field 3 String -MarshalAs @('LPWStr')
}

# the NetSessionEnum result structure
$SESSION_INFO_10 = struct $Mod SESSION_INFO_10 @{
    sesi10_cname = field 0 String -MarshalAs @('LPWStr')
    sesi10_username = field 1 String -MarshalAs @('LPWStr')
    sesi10_time = field 2 UInt32
    sesi10_idle_time = field 3 UInt32
}

# the NetFileEnum result structure
$FILE_INFO_3 = struct $Mod FILE_INFO_3 @{
    fi3_id = field 0 UInt32
    fi3_permissions = field 1 UInt32
    fi3_num_locks = field 2 UInt32
    fi3_pathname = field 3 String -MarshalAs @('LPWStr')
    fi3_username = field 4 String -MarshalAs @('LPWStr')
}

# the NetConnectionEnum result structure
$CONNECTION_INFO_1 = struct $Mod CONNECTION_INFO_1 @{
    coni1_id = field 0 UInt32
    coni1_type = field 1 UInt32
    coni1_num_opens = field 2 UInt32
    coni1_num_users = field 3 UInt32
    coni1_time = field 4 UInt32
    coni1_username = field 5 String -MarshalAs @('LPWStr')
    coni1_netname = field 6 String -MarshalAs @('LPWStr')
}

$Types = $FunctionDefinitions | Add-Win32Type -Module $Mod -Namespace 'Win32'
$Netapi32 = $Types['netapi32']
$Advapi32 = $Types['advapi32']
$Kernel32 = $Types['kernel32']
